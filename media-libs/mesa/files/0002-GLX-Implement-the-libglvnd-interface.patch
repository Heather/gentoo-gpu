From 9183b5cea6fc00645cee4d9c6f82038a45483d90 Mon Sep 17 00:00:00 2001
From: Kyle Brenneman <kbrenneman@nvidia.com>
Date: Tue, 29 Sep 2015 16:06:40 -0600
Subject: [PATCH 2/3] GLX: Implement the libglvnd interface.

Added a new file, glxglvnd.c, which contains the functions required to work as
a GLX vendor library.

Added a configuration option, --enable-libglvnd, to specify a libglvnd-based
build instead of a traditional libGL.so-based build.
---
 configure.ac                        |   22 +-
 include/libglvnd/GLdispatchABI.h    |  156 +++++
 include/libglvnd/libglxabi.h        |  275 +++++++++
 src/glx/Makefile.am                 |   30 +-
 src/glx/g_glxglvnddispatchfuncs.c   | 1150 +++++++++++++++++++++++++++++++++++
 src/glx/g_glxglvnddispatchindices.h |   98 +++
 src/glx/glxcmds.c                   |    2 +-
 src/glx/glxglvnd.c                  |   94 +++
 src/glx/glxglvnd.h                  |   24 +
 src/glx/glxglvnddispatchfuncs.h     |  113 ++++
 10 files changed, 1956 insertions(+), 8 deletions(-)
 create mode 100644 include/libglvnd/GLdispatchABI.h
 create mode 100644 include/libglvnd/libglxabi.h
 create mode 100644 src/glx/g_glxglvnddispatchfuncs.c
 create mode 100644 src/glx/g_glxglvnddispatchindices.h
 create mode 100644 src/glx/glxglvnd.c
 create mode 100644 src/glx/glxglvnd.h
 create mode 100644 src/glx/glxglvnddispatchfuncs.h

diff --git a/configure.ac b/configure.ac
index b05f33d..695694e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -519,6 +519,23 @@ else
    DEFINES="$DEFINES -DNDEBUG"
 fi
 
+DEFAULT_GL_LIB_NAME=GL
+
+dnl
+dnl Libglvnd configuration
+dnl
+AC_ARG_ENABLE([libglvnd],
+    [AS_HELP_STRING([--enable-libglvnd],
+        [Build for libglvnd @<:@default=disabled@:>@])],
+    [enable_libglvnd="$enableval"],
+    [enable_libglvnd=no])
+AM_CONDITIONAL(USE_LIBGLVND_GLX, test "x$enable_libglvnd" = xyes)
+#AM_COND_IF([USE_LIBGLVND_GLX], [DEFINES="${DEFINES} -DUSE_LIBGLVND_GLX=1"])
+if test "x$enable_libglvnd" = xyes ; then
+    DEFINES="${DEFINES} -DUSE_LIBGLVND_GLX=1"
+    DEFAULT_GL_LIB_NAME=GLX_mesa
+fi
+
 dnl
 dnl Check if linker supports -Bsymbolic
 dnl
@@ -653,13 +670,13 @@ AC_ARG_WITH([gl-lib-name],
   [AS_HELP_STRING([--with-gl-lib-name@<:@=NAME@:>@],
     [specify GL library name @<:@default=GL@:>@])],
   [GL_LIB=$withval],
-  [GL_LIB=GL])
+  [GL_LIB="$DEFAULT_GL_LIB_NAME"])
 AC_ARG_WITH([osmesa-lib-name],
   [AS_HELP_STRING([--with-osmesa-lib-name@<:@=NAME@:>@],
     [specify OSMesa library name @<:@default=OSMesa@:>@])],
   [OSMESA_LIB=$withval],
   [OSMESA_LIB=OSMesa])
-AS_IF([test "x$GL_LIB" = xyes], [GL_LIB=GL])
+AS_IF([test "x$GL_LIB" = xyes], [GL_LIB="$DEFAULT_GL_LIB_NAME"])
 AS_IF([test "x$OSMESA_LIB" = xyes], [OSMESA_LIB=OSMesa])
 
 dnl
@@ -1976,7 +1993,6 @@ AC_ARG_WITH([llvm-prefix],
     [llvm_prefix="$withval"],
     [llvm_prefix=''])
 
-
 # Call this inside ` ` to get the return value.
 # $1 is the llvm-config command with arguments.
 strip_unwanted_llvm_flags() {
diff --git a/include/libglvnd/GLdispatchABI.h b/include/libglvnd/GLdispatchABI.h
new file mode 100644
index 0000000..289811b
--- /dev/null
+++ b/include/libglvnd/GLdispatchABI.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2013, NVIDIA CORPORATION.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and/or associated documentation files (the
+ * "Materials"), to deal in the Materials without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Materials, and to
+ * permit persons to whom the Materials are furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * unaltered in all copies or substantial portions of the Materials.
+ * Any additions, deletions, or changes to the original source files
+ * must be clearly indicated in accompanying documentation.
+ *
+ * If only executable code is distributed, then the accompanying
+ * documentation must state that "this software is based in part on the
+ * work of the Khronos Group."
+ *
+ * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+ */
+
+#include <GL/gl.h>
+
+#if !defined(__GL_DISPATCH_ABI_H)
+#define __GL_DISPATCH_ABI_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/*!
+ * \defgroup gldispatchabi GL dispatching ABI
+ *
+ * This is not a complete ABI, but rather a fragment common to the libEGL and
+ * libGLX ABIs.  Changes to this file should be accompanied by a version bump to
+ * these client ABIs.
+ */
+
+/*!
+ * This opaque structure describes the core GL dispatch table.
+ */
+typedef struct __GLdispatchTableRec __GLdispatchTable;
+
+typedef void (*__GLdispatchProc)(void);
+
+typedef void *(*__GLgetProcAddressCallback)(const GLubyte *procName);
+
+/*
+ * Thread-local implementation used by libglvnd.  This is passed into
+ * the patch function callback via the type parameter.
+ */
+enum {
+    __GLDISPATCH_STUB_X86_TLS,
+    __GLDISPATCH_STUB_X86_64_TLS,
+    __GLDISPATCH_STUB_X86_TSD,
+    __GLDISPATCH_STUB_PURE_C,
+    __GLDISPATCH_STUB_X86_64_TSD,
+    __GLDISPATCH_STUB_ARMV7_THUMB_TSD,
+    __GLDISPATCH_STUB_NUM_TYPES
+};
+
+/*!
+ * A callback function called by the vendor library to fetch the address of an
+ * entrypoint.
+ *
+ * The function returns two pointers, one writable and one executable. The two
+ * pointers may or may not be the same virtual address, but they will both be
+ * mappings of the same physical memory.
+ *
+ * The vendor library should write its entrypoint to the address returned by
+ * \p writePtr, but should use the address from \p execPtr for things like
+ * calculating PC-relative offsets.
+ *
+ * Note that if this function fails, then the vendor library can still try to
+ * patch other entrypoints.
+ *
+ * Note that on ARM, the low-order bit of both \c execPtr and \p writePtr will
+ * be zero, even if the stub uses the thumb instruction set. The vendor library
+ * should use the \c type parameter of \c initiatePatch to determine which
+ * instruction set to use.
+ *
+ * \param funcName The function name.
+ * \param[out] writePtr The pointer that the vendor library can write to.
+ * \param[out] execPtr The pointer to the executable code.
+ * \return GL_TRUE if the entrypoint exists, or GL_FALSE if it doesn't.
+ */
+typedef GLboolean (*DispatchPatchLookupStubOffset)(const char *funcName,
+        void **writePtr, const void **execPtr);
+
+typedef struct __GLdispatchPatchCallbacksRec {
+    /*!
+     * Checks to see if the vendor library supports patching the given stub
+     * type and size.
+     *
+     * \param type The type of entrypoints. This will be a one of the
+     * __GLDISPATCH_STUB_* values.
+     * \param stubSize The maximum size of the stub that the vendor library can
+     * write, in bytes.
+     * \param lookupStubOffset A callback into libglvnd to look up the address
+     * of each entrypoint.
+     */
+    GLboolean (* checkPatchSupported)(int type, int stubSize);
+
+    /*!
+     * Called by libglvnd to request that a vendor library patch its top-level
+     * entrypoints.
+     *
+     * The vendor library should use the \p lookupStubOffset callback to find
+     * the addresses of each entrypoint.
+     *
+     * This function may be called more than once to patch multiple sets of
+     * entrypoints. For example, depending on how they're built, libOpenGL.so
+     * or libGL.so may have their own entrypoints that are separate functions
+     * from the ones in libGLdispatch.
+     *
+     * Note that during this call is the only time that the entrypoints can be
+     * modified. After the call to \c initiatePatch returns, the vendor library
+     * should treat the entrypoints as read-only.
+     *
+     * \param type The type of entrypoints. This will be a one of the
+     * __GLDISPATCH_STUB_* values.
+     * \param stubSize The maximum size of the stub that the vendor library can
+     * write, in bytes.
+     * \param lookupStubOffset A callback into libglvnd to look up the address
+     * of each entrypoint.
+     *
+     * \return GL_TRUE if the vendor library supports patching with this type
+     * and size.
+     */
+    GLboolean (*initiatePatch)(int type,
+                               int stubSize,
+                               DispatchPatchLookupStubOffset lookupStubOffset);
+
+    /*!
+     * Called by libglvnd to notify the current vendor that it no longer owns
+     * the top-level entrypoints.
+     *
+     * Libglvnd will take care of the restoring the entrypoints back to their
+     * original state. The vendor library must not try to modify them.
+     */
+    void (*releasePatch)(void);
+} __GLdispatchPatchCallbacks;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // __GL_DISPATCH_ABI_H
diff --git a/include/libglvnd/libglxabi.h b/include/libglvnd/libglxabi.h
new file mode 100644
index 0000000..ccf7eee
--- /dev/null
+++ b/include/libglvnd/libglxabi.h
@@ -0,0 +1,275 @@
+/*
+ * Copyright (c) 2013, NVIDIA CORPORATION.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and/or associated documentation files (the
+ * "Materials"), to deal in the Materials without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Materials, and to
+ * permit persons to whom the Materials are furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * unaltered in all copies or substantial portions of the Materials.
+ * Any additions, deletions, or changes to the original source files
+ * must be clearly indicated in accompanying documentation.
+ *
+ * If only executable code is distributed, then the accompanying
+ * documentation must state that "this software is based in part on the
+ * work of the Khronos Group."
+ *
+ * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+ */
+
+#if !defined(__LIB_GLX_ABI_H)
+#define __LIB_GLX_ABI_H
+
+#include <stdint.h>
+#include <GL/glx.h>
+
+#include "GLdispatchABI.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/*!
+ * \defgroup glxvendorabi GLX Vendor ABI
+ *
+ * Definition of ABI exported by libGLX.so to libGLX_VENDOR.so libraries.
+ *
+ * Each vendor is associated with three distinct dispatch table types:
+ *
+ * - static GLX dispatch table: this is the fixed list of GLX 1.4 entrypoints
+ *   provided by the vendor at load time during the initial handshake.
+ * - dynamic GLX dispatch table: this is a structure allocated by the API
+ *   library at runtime used to manage GLX extension functions which are not
+ *   present in the static table.
+ * - core GL dispatch table: this is a structure maintained by the API library
+ *   which contains both GL core (static) and GL extension (dynamic) functions.
+ *
+ * @{
+ */
+
+/*!
+ * Current version of the ABI.
+ */
+#define GLX_VENDOR_ABI_VERSION 0
+
+
+/*!
+ * This opaque structure stores function pointers for GLX extension functions.
+ * It is allocated at runtime by the API library. Vendor-provided dispatch
+ * functions retrieve and operate on this structure using the API below.
+ */
+typedef struct __GLXvendorInfoRec __GLXvendorInfo;
+
+/****************************************************************************
+ * API library exports                                                      *
+ ****************************************************************************/
+
+typedef struct __GLXapiExportsRec {
+    /************************************************************************
+     * The following routines are used by vendor-implemented GLX dispatch
+     * functions to lookup and call into the right vendor.
+     ************************************************************************/
+
+    /*!
+     * This fetches the appropriate dynamic GLX dispatch table given the display
+     * and screen number.
+     */
+    __GLXvendorInfo *(*getDynDispatch)(Display *dpy,
+                                                 const int screen);
+
+    /*!
+     * This function retrieves the appropriate current dynamic dispatch table,
+     * if a GL context is current. Otherwise, this returns NULL.
+     */
+    __GLXvendorInfo *(*getCurrentDynDispatch)(void);
+
+    /*!
+     * This function retrieves an entry point from the dynamic dispatch table
+     * given an index into the table.
+     */
+    __GLXextFuncPtr           (*fetchDispatchEntry)
+        (__GLXvendorInfo *dynDispatch, int index);
+
+    /************************************************************************
+     * This routine is used by the vendor to lookup its context structure.
+     * The contents of this structure are opaque to the API library and
+     * vendor-dependent.
+     ************************************************************************/
+
+    /*!
+     * This retrieves the current context for this thread.
+     */
+    GLXContext                (*getCurrentContext)(void);
+
+    /************************************************************************
+     * These routines are used by vendor dispatch functions to look up
+     * and add mappings between various objects and screens.
+     ************************************************************************/
+
+    /*!
+     * Records the screen number and vendor for a context. The screen and
+     * vendor must be the ones returned for the XVisualInfo or GLXFBConfig that
+     * the context is created from.
+     */
+    void (*addScreenContextMapping)(Display *dpy, GLXContext context, int screen, __GLXvendorInfo *vendor);
+
+    /*!
+     * Removes a mapping from context to vendor. The context must have been
+     * added with \p addScreenContextMapping.
+     */
+    void (*removeScreenContextMapping)(Display *dpy, GLXContext context);
+
+    /*!
+     * Looks up the screen and vendor for a context.
+     *
+     * If no mapping is found, then \p retScreen and \p retVendor will be set
+     * to -1 and NULL, respectively.
+     *
+     * Either of \p retScreen or \p retVendor may be NULL if the screen or
+     * vendor are not required.
+     *
+     * \param dpy The display connection.
+     * \param context The context to look up.
+     * \param[out] retScreen Returns the screen number.
+     * \param[out] retVendor Returns the vendor.
+     * \return Zero if a match was found, or non-zero if it was not.
+     */
+    int (*vendorFromContext)(Display *dpy, GLXContext context, int *retScreen, __GLXvendorInfo **retVendor);
+
+    void (*addScreenFBConfigMapping)(Display *dpy, GLXFBConfig config, int screen, __GLXvendorInfo *vendor);
+    void (*removeScreenFBConfigMapping)(Display *dpy, GLXFBConfig config);
+    int (*vendorFromFBConfig)(Display *dpy, GLXFBConfig config, int *retScreen, __GLXvendorInfo **retVendor);
+
+    void (*addScreenVisualMapping)(Display *dpy, const XVisualInfo *visual, __GLXvendorInfo *vendor);
+    void (*removeScreenVisualMapping)(Display *dpy, const XVisualInfo *visual);
+    int (*vendorFromVisual)(Display *dpy, const XVisualInfo *visual, __GLXvendorInfo **retVendor);
+
+    void (*addScreenDrawableMapping)(Display *dpy, GLXDrawable drawable, int screen, __GLXvendorInfo *vendor);
+    void (*removeScreenDrawableMapping)(Display *dpy, GLXDrawable drawable);
+
+    /*!
+     * Looks up the screen and vendor for a drawable.
+     *
+     * If the server does not support the x11glvnd extension, then this
+     * function may not be able to determine the screen number for a drawable.
+     * In that case, it will return -1 for the screen number.
+     *
+     * Even without x11glvnd, this function will still return a vendor
+     * suitable for indirect rendering.
+     */
+    int (*vendorFromDrawable)(Display *dpy, GLXDrawable drawable, int *retScreen, __GLXvendorInfo **retVendor);
+
+} __GLXapiExports;
+
+/*****************************************************************************
+ * API library imports                                                       *
+ *****************************************************************************/
+
+/*!
+ * This structure stores required and optional vendor library callbacks.
+ */
+typedef struct __GLXapiImportsRec {
+    /*!
+     * Checks if the vendor library can support a given X screen. If this
+     * returns false, then libGLX will fall back to the indirect rendering
+     * library (if one exists).
+     *
+     * \param dpy The display connection.
+     * \param screen The screen number.
+     * \return True if the vendor library can support this screen.
+     */
+    Bool (* checkSupportsScreen) (Display *dpy, int screen);
+
+    /*!
+     * This retrieves the pointer to the real GLX or core GL function.
+     *
+     * \param procName The name of the function.
+     * \return A pointer to a function, or \c NULL if the vendor does not
+     * support the function.
+     */
+    void        *(*getProcAddress)        (const GLubyte *procName);
+
+    /*!
+     * This retrieves vendor-neutral functions which use the
+     * __GLXdispatchTableDynamic API above to dispatch to the correct vendor.
+     *
+     * A vendor library must provide a dispatch function for all GLX functions
+     * that it supports. If \c getDispatchAddress returns NULL, but
+     * \c getProcAddress returns non-NULL, then libGLX will assume that the
+     * function is a GL function, not GLX.
+     *
+     * That allows libGLX to dispatch GL and GLX functions correctly, even in
+     * the case of a GL function that starts with "glX".
+     *
+     * \param procName The name of the function.
+     * \return A pointer to a function, or \c NULL if the vendor does not
+     * support the function or \p procName is not a GLX function.
+     */
+    void        *(*getDispatchAddress)    (const GLubyte *procName);
+
+    /*!
+     * This notifies the vendor library which dispatch table index is
+     * assigned to a particular GLX extension function.
+     */
+    void        (*setDispatchIndex)      (const GLubyte *procName, int index);
+
+    /*!
+     * This notifies the vendor library when an X error should be generated
+     * due to a detected error in the GLX API stream.
+     */
+    void        (*notifyError)  (Display *dpy, char error,
+                                 char opcode, XID resid);
+
+    /*!
+     * (OPTIONAL) Callbacks by which the vendor library may re-write libglvnd's
+     * entrypoints at make current time, provided no other contexts are current
+     * and the TLS model supports this functionality.  This is a performance
+     * optimization that may not be available at runtime; the vendor library
+     * must not depend on this functionality for correctness.  This should
+     * point to a statically-allocated structure, or NULL if unimplemented.
+     */
+    const __GLdispatchPatchCallbacks *patchCallbacks;
+
+} __GLXapiImports;
+
+/*****************************************************************************/
+
+/*!
+ * Vendor libraries must export a function called __glx_Main() with the
+ * following prototype. This function also performs a handshake based on the ABI
+ * version number. This function receives a pointer to an exports table whose
+ * lifetime is only guaranteed to be at a minimum that of the call to
+ * __glx_Main(), in addition to the version number and a string identifying the
+ * vendor. If there is an ABI version mismatch or some other error occurs, this
+ * function returns NULL; otherwise this returns a pointer to a filled-in
+ * dispatch table.
+ */
+#define __GLX_MAIN_PROTO_NAME "__glx_Main"
+#define __GLX_MAIN_PROTO(version, exports, vendorName)                \
+    const __GLXapiImports *__glx_Main(uint32_t version,               \
+                                      const __GLXapiExports *exports, \
+                                      const char *vendorName,         \
+                                      int vendorID)
+
+typedef const __GLXapiImports *(*__PFNGLXMAINPROC)
+    (uint32_t, const __GLXapiExports *, const char *, int);
+
+/*!
+ * @}
+ */
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* __LIB_GLX_ABI_H */
diff --git a/src/glx/Makefile.am b/src/glx/Makefile.am
index 0092545..eb9eb61 100644
--- a/src/glx/Makefile.am
+++ b/src/glx/Makefile.am
@@ -46,7 +46,6 @@ AM_CFLAGS = \
 	$(EXTRA_DEFINES_XF86VIDMODE) \
 	-D_REENTRANT \
 	-DDEFAULT_DRIVER_DIR=\"$(DRI_DRIVER_SEARCH_DIR)\" \
-	-DGL_LIB_NAME=\"lib@GL_LIB@.so.1\" \
 	$(DEFINES) \
 	$(LIBDRM_CFLAGS) \
 	$(DRI2PROTO_CFLAGS) \
@@ -145,6 +144,24 @@ SUBDIRS += apple
 libglx_la_LIBADD += $(builddir)/apple/libappleglx.la
 endif
 
+if USE_LIBGLVND_GLX
+AM_CFLAGS += \
+	-DGL_LIB_NAME=\"lib@GL_LIB@.so.0\" \
+	-I$(top_srcdir)/include/libglvnd
+
+libglx_la_SOURCES += \
+          glxglvnd.c \
+          g_glxglvnddispatchfuncs.c
+
+GL_LIB_VERSION=0
+else
+AM_CFLAGS += \
+	-DGL_LIB_NAME=\"lib@GL_LIB@.so.1\"
+GL_LIB_VERSION=1:2
+endif
+
+libglx_la_LIBADD = $(top_builddir)/src/loader/libloader.la
+
 GL_LIBS = \
 	libglx.la \
 	$(top_builddir)/src/mapi/glapi/libglapi.la \
@@ -152,11 +169,16 @@ GL_LIBS = \
 	$(GL_LIB_DEPS)
 
 GL_LDFLAGS = \
-	-no-undefined \
-	-version-number 1:2 \
 	$(BSYMBOLIC) \
 	$(GC_SECTIONS) \
-	$(LD_NO_UNDEFINED)
+	$(LD_NO_UNDEFINED) \
+	-version-number $(GL_LIB_VERSION) -no-undefined
+
+#if USE_LIBGLVND_GLX
+#GL_LDFLAGS += -version-number 0
+#else
+#GL_LDFLAGS += -version-number 1:2
+#endif
 
 lib@GL_LIB@_la_SOURCES =
 lib@GL_LIB@_la_LIBADD = $(GL_LIBS)
diff --git a/src/glx/g_glxglvnddispatchfuncs.c b/src/glx/g_glxglvnddispatchfuncs.c
new file mode 100644
index 0000000..56ca182
--- /dev/null
+++ b/src/glx/g_glxglvnddispatchfuncs.c
@@ -0,0 +1,1150 @@
+/*
+ * THIS FILE IS AUTOMATICALLY GENERATED BY gen_scrn_dispatch.pl
+ * DO NOT EDIT!!
+ */
+
+#include "glxglvnd.h"
+#include "glxglvnddispatchfuncs.h"
+#include "g_glxglvnddispatchindices.h"
+
+const int DI_FUNCTION_COUNT = DI_LAST_INDEX;
+int __glXDispatchTableIndices[DI_LAST_INDEX];
+void *__glXDispatchFunctions[DI_LAST_INDEX];
+__GLXapiExports __glXGLVNDAPIExports;
+
+const char *__glXDispatchTableStrings[DI_LAST_INDEX] = {
+"glXBindTexImageEXT",
+// glXChooseFBConfig implemented by libglvnd
+"glXChooseFBConfigSGIX",
+// glXChooseVisual implemented by libglvnd
+// glXCopyContext implemented by libglvnd
+// glXCreateContext implemented by libglvnd
+"glXCreateContextAttribsARB",
+"glXCreateContextWithConfigSGIX",
+"glXCreateGLXPbufferSGIX",
+// glXCreateGLXPixmap implemented by libglvnd
+"glXCreateGLXPixmapWithConfigSGIX",
+// glXCreateNewContext implemented by libglvnd
+// glXCreatePbuffer implemented by libglvnd
+// glXCreatePixmap implemented by libglvnd
+// glXCreateWindow implemented by libglvnd
+// glXDestroyContext implemented by libglvnd
+"glXDestroyGLXPbufferSGIX",
+// glXDestroyGLXPixmap implemented by libglvnd
+// glXDestroyPbuffer implemented by libglvnd
+// glXDestroyPixmap implemented by libglvnd
+// glXDestroyWindow implemented by libglvnd
+"glXFreeContextEXT",
+// glXGetClientString implemented by libglvnd
+// glXGetConfig implemented by libglvnd
+"glXGetContextIDEXT",
+// glXGetCurrentContext implemented by libglvnd
+// glXGetCurrentDisplay implemented by libglvnd
+"glXGetCurrentDisplayEXT",
+// glXGetCurrentDrawable implemented by libglvnd
+// glXGetCurrentReadDrawable implemented by libglvnd
+// glXGetFBConfigAttrib implemented by libglvnd
+"glXGetFBConfigAttribSGIX",
+"glXGetFBConfigFromVisualSGIX",
+// glXGetFBConfigs implemented by libglvnd
+// glXGetProcAddress implemented by libglvnd
+// glXGetProcAddressARB implemented by libglvnd
+// glXGetSelectedEvent implemented by libglvnd
+"glXGetSelectedEventSGIX",
+#if defined(GLX_SGI_video_sync)
+"glXGetVideoSyncSGI",
+#endif // defined(GLX_SGI_video_sync)
+// glXGetVisualFromFBConfig implemented by libglvnd
+"glXGetVisualFromFBConfigSGIX",
+"glXImportContextEXT",
+// glXIsDirect implemented by libglvnd
+// glXMakeContextCurrent implemented by libglvnd
+// glXMakeCurrent implemented by libglvnd
+// glXQueryContext implemented by libglvnd
+"glXQueryContextInfoEXT",
+// glXQueryDrawable implemented by libglvnd
+// glXQueryExtension implemented by libglvnd
+// glXQueryExtensionsString implemented by libglvnd
+"glXQueryGLXPbufferSGIX",
+// glXQueryServerString implemented by libglvnd
+// glXQueryVersion implemented by libglvnd
+"glXReleaseTexImageEXT",
+// glXSelectEvent implemented by libglvnd
+"glXSelectEventSGIX",
+// glXSwapBuffers implemented by libglvnd
+#if defined(GLX_SGI_swap_control)
+"glXSwapIntervalSGI",
+#endif // defined(GLX_SGI_swap_control)
+// glXUseXFont implemented by libglvnd
+// glXWaitGL implemented by libglvnd
+#if defined(GLX_SGI_video_sync)
+"glXWaitVideoSyncSGI",
+#endif // defined(GLX_SGI_video_sync)
+// glXWaitX implemented by libglvnd
+"glXglXBindSwapBarrierSGIX",
+"glXglXCopySubBufferMESA",
+"glXglXCreateGLXPixmapMESA",
+"glXglXGetMscRateOML",
+"glXglXGetScreenDriver",
+"glXglXGetSwapIntervalMESA",
+"glXglXGetSyncValuesOML",
+"glXglXJoinSwapGroupSGIX",
+"glXglXQueryCurrentRendererIntegerMESA",
+"glXglXQueryCurrentRendererStringMESA",
+"glXglXQueryMaxSwapBarriersSGIX",
+"glXglXQueryRendererIntegerMESA",
+"glXglXQueryRendererStringMESA",
+"glXglXReleaseBuffersMESA",
+"glXglXSwapBuffersMscOML",
+"glXglXSwapIntervalMESA",
+"glXglXWaitForMscOML",
+"glXglXWaitForSbcOML",
+};
+
+static void dispatch_BindTexImageEXT(Display * dpy, GLXDrawable drawable, int buffer, const int * attrib_list)
+{
+
+    typedef void (*fn_BindTexImageEXT_ptr)(Display * dpy, GLXDrawable drawable, int buffer, const int * attrib_list);
+    fn_BindTexImageEXT_ptr pBindTexImageEXT;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pBindTexImageEXT = (fn_BindTexImageEXT_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_BindTexImageEXT]) :
+        NULL);
+    if (pBindTexImageEXT) {
+        (*pBindTexImageEXT)(dpy, drawable, buffer, attrib_list);
+    }
+
+}
+
+
+
+static GLXFBConfigSGIX * dispatch_ChooseFBConfigSGIX(Display * dpy, int screen, const int * attrib_list, int * nelements)
+{
+
+    typedef GLXFBConfigSGIX * (*fn_ChooseFBConfigSGIX_ptr)(Display * dpy, int screen, const int * attrib_list, int * nelements);
+    fn_ChooseFBConfigSGIX_ptr pChooseFBConfigSGIX;
+    __GLXvendorInfo *dd = NULL;
+    int disp_screen;
+    GLXFBConfigSGIX * ret = NULL;
+
+
+    dd = __VND.getDynDispatch(dpy, screen);
+    disp_screen = screen;
+    pChooseFBConfigSGIX = (fn_ChooseFBConfigSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_ChooseFBConfigSGIX]) :
+        NULL);
+    if (pChooseFBConfigSGIX) {
+        ret = (*pChooseFBConfigSGIX)(dpy, screen, attrib_list, nelements);
+    }
+
+    AddScreenFBConfigsMapping(dpy, ret, nelements, disp_screen, dd);
+
+    return ret;
+
+}
+
+
+
+static GLXContext dispatch_CreateContextAttribsARB(Display * dpy, GLXFBConfig config, GLXContext share_list, Bool direct, const int * attrib_list)
+{
+
+    typedef GLXContext (*fn_CreateContextAttribsARB_ptr)(Display * dpy, GLXFBConfig config, GLXContext share_list, Bool direct, const int * attrib_list);
+    fn_CreateContextAttribsARB_ptr pCreateContextAttribsARB;
+    __GLXvendorInfo *dd = NULL;
+    int disp_screen;
+    GLXContext ret = None;
+
+
+    GetDispatchFromFBConfig(dpy, config, &disp_screen, &dd);
+    pCreateContextAttribsARB = (fn_CreateContextAttribsARB_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_CreateContextAttribsARB]) :
+        NULL);
+    if (pCreateContextAttribsARB) {
+        ret = (*pCreateContextAttribsARB)(dpy, config, share_list, direct, attrib_list);
+    }
+
+    AddContextMapping(dpy, ret, disp_screen, dd);
+
+    return ret;
+
+}
+
+
+
+static GLXContext dispatch_CreateContextWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct)
+{
+
+    typedef GLXContext (*fn_CreateContextWithConfigSGIX_ptr)(Display * dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
+    fn_CreateContextWithConfigSGIX_ptr pCreateContextWithConfigSGIX;
+    __GLXvendorInfo *dd = NULL;
+    int disp_screen;
+    GLXContext ret = None;
+
+
+    GetDispatchFromFBConfig(dpy, config, &disp_screen, &dd);
+    pCreateContextWithConfigSGIX = (fn_CreateContextWithConfigSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_CreateContextWithConfigSGIX]) :
+        NULL);
+    if (pCreateContextWithConfigSGIX) {
+        ret = (*pCreateContextWithConfigSGIX)(dpy, config, render_type, share_list, direct);
+    }
+
+    AddContextMapping(dpy, ret, disp_screen, dd);
+
+    return ret;
+
+}
+
+
+
+static GLXPbuffer dispatch_CreateGLXPbufferSGIX(Display * dpy, GLXFBConfig config, unsigned int width, unsigned int height, const int * attrib_list)
+{
+
+    typedef GLXPbuffer (*fn_CreateGLXPbufferSGIX_ptr)(Display * dpy, GLXFBConfig config, unsigned int width, unsigned int height, const int * attrib_list);
+    fn_CreateGLXPbufferSGIX_ptr pCreateGLXPbufferSGIX;
+    __GLXvendorInfo *dd = NULL;
+    int disp_screen;
+    GLXPbuffer ret = None;
+
+
+    GetDispatchFromFBConfig(dpy, config, &disp_screen, &dd);
+    pCreateGLXPbufferSGIX = (fn_CreateGLXPbufferSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_CreateGLXPbufferSGIX]) :
+        NULL);
+    if (pCreateGLXPbufferSGIX) {
+        ret = (*pCreateGLXPbufferSGIX)(dpy, config, width, height, attrib_list);
+    }
+
+    AddDrawableMapping(dpy, ret, disp_screen, dd);
+
+    return ret;
+
+}
+
+
+
+static GLXPixmap dispatch_CreateGLXPixmapWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap)
+{
+
+    typedef GLXPixmap (*fn_CreateGLXPixmapWithConfigSGIX_ptr)(Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap);
+    fn_CreateGLXPixmapWithConfigSGIX_ptr pCreateGLXPixmapWithConfigSGIX;
+    __GLXvendorInfo *dd = NULL;
+    int disp_screen;
+    GLXPixmap ret = None;
+
+
+    GetDispatchFromFBConfig(dpy, config, &disp_screen, &dd);
+    pCreateGLXPixmapWithConfigSGIX = (fn_CreateGLXPixmapWithConfigSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_CreateGLXPixmapWithConfigSGIX]) :
+        NULL);
+    if (pCreateGLXPixmapWithConfigSGIX) {
+        ret = (*pCreateGLXPixmapWithConfigSGIX)(dpy, config, pixmap);
+    }
+
+    AddDrawableMapping(dpy, ret, disp_screen, dd);
+
+    return ret;
+
+}
+
+
+
+static void dispatch_DestroyGLXPbufferSGIX(Display * dpy, GLXPbuffer pbuf)
+{
+
+    typedef void (*fn_DestroyGLXPbufferSGIX_ptr)(Display * dpy, GLXPbuffer pbuf);
+    fn_DestroyGLXPbufferSGIX_ptr pDestroyGLXPbufferSGIX;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, pbuf, NULL, &dd);
+    pDestroyGLXPbufferSGIX = (fn_DestroyGLXPbufferSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_DestroyGLXPbufferSGIX]) :
+        NULL);
+    if (pDestroyGLXPbufferSGIX) {
+        (*pDestroyGLXPbufferSGIX)(dpy, pbuf);
+    }
+
+}
+
+
+
+static void dispatch_FreeContextEXT(Display * dpy, GLXContext ctx)
+{
+
+    typedef void (*fn_FreeContextEXT_ptr)(Display * dpy, GLXContext ctx);
+    fn_FreeContextEXT_ptr pFreeContextEXT;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromContext(dpy, ctx, NULL, &dd);
+    pFreeContextEXT = (fn_FreeContextEXT_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_FreeContextEXT]) :
+        NULL);
+    if (pFreeContextEXT) {
+        (*pFreeContextEXT)(dpy, ctx);
+    }
+
+}
+
+
+
+static GLXContextID dispatch_GetContextIDEXT(const GLXContext ctx)
+{
+
+    typedef GLXContextID (*fn_GetContextIDEXT_ptr)(const GLXContext ctx);
+    fn_GetContextIDEXT_ptr pGetContextIDEXT;
+    __GLXvendorInfo *dd = NULL;
+    Display *dpy = GET_DEFAULT_DISPLAY();
+    GLXContextID ret = None;
+
+
+    GetDispatchFromContext(dpy, ctx, NULL, &dd);
+    pGetContextIDEXT = (fn_GetContextIDEXT_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_GetContextIDEXT]) :
+        NULL);
+    if (pGetContextIDEXT) {
+        ret = (*pGetContextIDEXT)(ctx);
+    }
+
+    return ret;
+
+}
+
+
+
+static Display * dispatch_GetCurrentDisplayEXT(void)
+{
+
+    typedef Display * (*fn_GetCurrentDisplayEXT_ptr)(void);
+    fn_GetCurrentDisplayEXT_ptr pGetCurrentDisplayEXT;
+    __GLXvendorInfo *dd = NULL;
+    Display * ret = NULL;
+
+
+    if (!__VND.getCurrentContext()) {
+        return ret;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pGetCurrentDisplayEXT = (fn_GetCurrentDisplayEXT_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_GetCurrentDisplayEXT]) :
+        NULL);
+    if (pGetCurrentDisplayEXT) {
+        ret = (*pGetCurrentDisplayEXT)();
+    }
+
+    return ret;
+
+}
+
+
+
+static int dispatch_GetFBConfigAttribSGIX(Display * dpy, GLXFBConfigSGIX config, int attribute, int * value_return)
+{
+
+    typedef int (*fn_GetFBConfigAttribSGIX_ptr)(Display * dpy, GLXFBConfigSGIX config, int attribute, int * value_return);
+    fn_GetFBConfigAttribSGIX_ptr pGetFBConfigAttribSGIX;
+    __GLXvendorInfo *dd = NULL;
+    int ret = GLX_NO_EXTENSION;
+
+
+    GetDispatchFromFBConfig(dpy, config, NULL, &dd);
+    pGetFBConfigAttribSGIX = (fn_GetFBConfigAttribSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_GetFBConfigAttribSGIX]) :
+        NULL);
+    if (pGetFBConfigAttribSGIX) {
+        ret = (*pGetFBConfigAttribSGIX)(dpy, config, attribute, value_return);
+    }
+
+    return ret;
+
+}
+
+
+
+static GLXFBConfigSGIX dispatch_GetFBConfigFromVisualSGIX(Display * dpy, XVisualInfo * vis)
+{
+
+    typedef GLXFBConfigSGIX (*fn_GetFBConfigFromVisualSGIX_ptr)(Display * dpy, XVisualInfo * vis);
+    fn_GetFBConfigFromVisualSGIX_ptr pGetFBConfigFromVisualSGIX;
+    __GLXvendorInfo *dd = NULL;
+    int disp_screen;
+    GLXFBConfigSGIX ret = NULL;
+
+
+    GetDispatchFromVisual(dpy, vis, &dd);
+    disp_screen = vis->screen;
+    pGetFBConfigFromVisualSGIX = (fn_GetFBConfigFromVisualSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_GetFBConfigFromVisualSGIX]) :
+        NULL);
+    if (pGetFBConfigFromVisualSGIX) {
+        ret = (*pGetFBConfigFromVisualSGIX)(dpy, vis);
+    }
+
+    AddFBConfigMapping(dpy, ret, disp_screen, dd);
+
+    return ret;
+
+}
+
+
+
+static void dispatch_GetSelectedEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long * mask)
+{
+
+    typedef void (*fn_GetSelectedEventSGIX_ptr)(Display * dpy, GLXDrawable drawable, unsigned long * mask);
+    fn_GetSelectedEventSGIX_ptr pGetSelectedEventSGIX;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pGetSelectedEventSGIX = (fn_GetSelectedEventSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_GetSelectedEventSGIX]) :
+        NULL);
+    if (pGetSelectedEventSGIX) {
+        (*pGetSelectedEventSGIX)(dpy, drawable, mask);
+    }
+
+}
+
+
+
+#if defined(GLX_SGI_video_sync)
+static int dispatch_GetVideoSyncSGI(unsigned int * count)
+{
+
+    typedef int (*fn_GetVideoSyncSGI_ptr)(unsigned int * count);
+    fn_GetVideoSyncSGI_ptr pGetVideoSyncSGI;
+    __GLXvendorInfo *dd = NULL;
+    int ret = GLX_NO_EXTENSION;
+
+
+    if (!__VND.getCurrentContext()) {
+        return GLX_BAD_CONTEXT;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pGetVideoSyncSGI = (fn_GetVideoSyncSGI_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_GetVideoSyncSGI]) :
+        NULL);
+    if (pGetVideoSyncSGI) {
+        ret = (*pGetVideoSyncSGI)(count);
+    }
+
+    return ret;
+
+}
+#endif // defined(GLX_SGI_video_sync)
+
+
+
+static XVisualInfo * dispatch_GetVisualFromFBConfigSGIX(Display * dpy, GLXFBConfigSGIX config)
+{
+
+    typedef XVisualInfo * (*fn_GetVisualFromFBConfigSGIX_ptr)(Display * dpy, GLXFBConfigSGIX config);
+    fn_GetVisualFromFBConfigSGIX_ptr pGetVisualFromFBConfigSGIX;
+    __GLXvendorInfo *dd = NULL;
+    XVisualInfo * ret = NULL;
+
+
+    GetDispatchFromFBConfig(dpy, config, NULL, &dd);
+    pGetVisualFromFBConfigSGIX = (fn_GetVisualFromFBConfigSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_GetVisualFromFBConfigSGIX]) :
+        NULL);
+    if (pGetVisualFromFBConfigSGIX) {
+        ret = (*pGetVisualFromFBConfigSGIX)(dpy, config);
+    }
+
+    AddVisualMapping(dpy, ret, dd);
+
+    return ret;
+
+}
+
+
+
+static GLXContext dispatch_ImportContextEXT(Display * dpy, GLXContextID contextID)
+{
+
+    typedef GLXContext (*fn_ImportContextEXT_ptr)(Display * dpy, GLXContextID contextID);
+    fn_ImportContextEXT_ptr pImportContextEXT;
+    __GLXvendorInfo *dd = NULL;
+    GLXContext ret = None;
+
+
+    dd = __VND.getDynDispatch(dpy, GET_DEFAULT_SCREEN());
+    pImportContextEXT = (fn_ImportContextEXT_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_ImportContextEXT]) :
+        NULL);
+    if (pImportContextEXT) {
+        ret = (*pImportContextEXT)(dpy, contextID);
+    }
+
+    return ret;
+
+}
+
+
+
+static int dispatch_QueryContextInfoEXT(Display * dpy, GLXContext ctx, int attribute, int * value)
+{
+
+    typedef int (*fn_QueryContextInfoEXT_ptr)(Display * dpy, GLXContext ctx, int attribute, int * value);
+    fn_QueryContextInfoEXT_ptr pQueryContextInfoEXT;
+    __GLXvendorInfo *dd = NULL;
+    int ret = GLX_NO_EXTENSION;
+
+
+    GetDispatchFromContext(dpy, ctx, NULL, &dd);
+    pQueryContextInfoEXT = (fn_QueryContextInfoEXT_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_QueryContextInfoEXT]) :
+        NULL);
+    if (pQueryContextInfoEXT) {
+        ret = (*pQueryContextInfoEXT)(dpy, ctx, attribute, value);
+    }
+
+    return ret;
+
+}
+
+
+
+static void dispatch_QueryGLXPbufferSGIX(Display * dpy, GLXPbuffer pbuf, int attribute, unsigned int * value)
+{
+
+    typedef void (*fn_QueryGLXPbufferSGIX_ptr)(Display * dpy, GLXPbuffer pbuf, int attribute, unsigned int * value);
+    fn_QueryGLXPbufferSGIX_ptr pQueryGLXPbufferSGIX;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, pbuf, NULL, &dd);
+    pQueryGLXPbufferSGIX = (fn_QueryGLXPbufferSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_QueryGLXPbufferSGIX]) :
+        NULL);
+    if (pQueryGLXPbufferSGIX) {
+        (*pQueryGLXPbufferSGIX)(dpy, pbuf, attribute, value);
+    }
+
+}
+
+
+
+static void dispatch_ReleaseTexImageEXT(Display * dpy, GLXDrawable drawable, int buffer)
+{
+
+    typedef void (*fn_ReleaseTexImageEXT_ptr)(Display * dpy, GLXDrawable drawable, int buffer);
+    fn_ReleaseTexImageEXT_ptr pReleaseTexImageEXT;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pReleaseTexImageEXT = (fn_ReleaseTexImageEXT_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_ReleaseTexImageEXT]) :
+        NULL);
+    if (pReleaseTexImageEXT) {
+        (*pReleaseTexImageEXT)(dpy, drawable, buffer);
+    }
+
+}
+
+
+
+static void dispatch_SelectEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long mask)
+{
+
+    typedef void (*fn_SelectEventSGIX_ptr)(Display * dpy, GLXDrawable drawable, unsigned long mask);
+    fn_SelectEventSGIX_ptr pSelectEventSGIX;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pSelectEventSGIX = (fn_SelectEventSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_SelectEventSGIX]) :
+        NULL);
+    if (pSelectEventSGIX) {
+        (*pSelectEventSGIX)(dpy, drawable, mask);
+    }
+
+}
+
+
+
+#if defined(GLX_SGI_swap_control)
+static int dispatch_SwapIntervalSGI(int interval)
+{
+
+    typedef int (*fn_SwapIntervalSGI_ptr)(int interval);
+    fn_SwapIntervalSGI_ptr pSwapIntervalSGI;
+    __GLXvendorInfo *dd = NULL;
+    int ret = GLX_NO_EXTENSION;
+
+
+    if (!__VND.getCurrentContext()) {
+        return GLX_BAD_CONTEXT;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pSwapIntervalSGI = (fn_SwapIntervalSGI_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_SwapIntervalSGI]) :
+        NULL);
+    if (pSwapIntervalSGI) {
+        ret = (*pSwapIntervalSGI)(interval);
+    }
+
+    return ret;
+
+}
+#endif // defined(GLX_SGI_swap_control)
+
+
+
+#if defined(GLX_SGI_video_sync)
+static int dispatch_WaitVideoSyncSGI(int divisor, int remainder, unsigned int * count)
+{
+
+    typedef int (*fn_WaitVideoSyncSGI_ptr)(int divisor, int remainder, unsigned int * count);
+    fn_WaitVideoSyncSGI_ptr pWaitVideoSyncSGI;
+    __GLXvendorInfo *dd = NULL;
+    int ret = GLX_NO_EXTENSION;
+
+
+    if (!__VND.getCurrentContext()) {
+        return GLX_BAD_CONTEXT;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pWaitVideoSyncSGI = (fn_WaitVideoSyncSGI_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_WaitVideoSyncSGI]) :
+        NULL);
+    if (pWaitVideoSyncSGI) {
+        ret = (*pWaitVideoSyncSGI)(divisor, remainder, count);
+    }
+
+    return ret;
+
+}
+#endif // defined(GLX_SGI_video_sync)
+
+
+
+static void dispatch_glXBindSwapBarrierSGIX(Display * dpy, GLXDrawable drawable, int barrier)
+{
+
+    typedef void (*fn_glXBindSwapBarrierSGIX_ptr)(Display * dpy, GLXDrawable drawable, int barrier);
+    fn_glXBindSwapBarrierSGIX_ptr pglXBindSwapBarrierSGIX;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXBindSwapBarrierSGIX = (fn_glXBindSwapBarrierSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXBindSwapBarrierSGIX]) :
+        NULL);
+    if (pglXBindSwapBarrierSGIX) {
+        (*pglXBindSwapBarrierSGIX)(dpy, drawable, barrier);
+    }
+
+}
+
+
+
+static void dispatch_glXCopySubBufferMESA(Display * dpy, GLXDrawable drawable, int x, int y, int width, int height)
+{
+
+    typedef void (*fn_glXCopySubBufferMESA_ptr)(Display * dpy, GLXDrawable drawable, int x, int y, int width, int height);
+    fn_glXCopySubBufferMESA_ptr pglXCopySubBufferMESA;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXCopySubBufferMESA = (fn_glXCopySubBufferMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXCopySubBufferMESA]) :
+        NULL);
+    if (pglXCopySubBufferMESA) {
+        (*pglXCopySubBufferMESA)(dpy, drawable, x, y, width, height);
+    }
+
+}
+
+
+
+static GLXPixmap dispatch_glXCreateGLXPixmapMESA(Display * dpy, XVisualInfo * visinfo, Pixmap pixmap, Colormap cmap)
+{
+
+    typedef GLXPixmap (*fn_glXCreateGLXPixmapMESA_ptr)(Display * dpy, XVisualInfo * visinfo, Pixmap pixmap, Colormap cmap);
+    fn_glXCreateGLXPixmapMESA_ptr pglXCreateGLXPixmapMESA;
+    __GLXvendorInfo *dd = NULL;
+    int disp_screen;
+    GLXPixmap ret = None;
+
+
+    GetDispatchFromVisual(dpy, visinfo, &dd);
+    disp_screen = visinfo->screen;
+    pglXCreateGLXPixmapMESA = (fn_glXCreateGLXPixmapMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXCreateGLXPixmapMESA]) :
+        NULL);
+    if (pglXCreateGLXPixmapMESA) {
+        ret = (*pglXCreateGLXPixmapMESA)(dpy, visinfo, pixmap, cmap);
+    }
+
+    AddDrawableMapping(dpy, ret, disp_screen, dd);
+
+    return ret;
+
+}
+
+
+
+static GLboolean dispatch_glXGetMscRateOML(Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator)
+{
+
+    typedef GLboolean (*fn_glXGetMscRateOML_ptr)(Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator);
+    fn_glXGetMscRateOML_ptr pglXGetMscRateOML;
+    __GLXvendorInfo *dd = NULL;
+    GLboolean ret = GL_FALSE;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXGetMscRateOML = (fn_glXGetMscRateOML_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXGetMscRateOML]) :
+        NULL);
+    if (pglXGetMscRateOML) {
+        ret = (*pglXGetMscRateOML)(dpy, drawable, numerator, denominator);
+    }
+
+    return ret;
+
+}
+
+
+
+static const char * dispatch_glXGetScreenDriver(Display * dpy, int scrNum)
+{
+
+    typedef const char * (*fn_glXGetScreenDriver_ptr)(Display * dpy, int scrNum);
+    fn_glXGetScreenDriver_ptr pglXGetScreenDriver;
+    __GLXvendorInfo *dd = NULL;
+    const char * ret = NULL;
+
+
+    dd = __VND.getDynDispatch(dpy, scrNum);
+    pglXGetScreenDriver = (fn_glXGetScreenDriver_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXGetScreenDriver]) :
+        NULL);
+    if (pglXGetScreenDriver) {
+        ret = (*pglXGetScreenDriver)(dpy, scrNum);
+    }
+
+    return ret;
+
+}
+
+
+
+static int dispatch_glXGetSwapIntervalMESA(void)
+{
+
+    typedef int (*fn_glXGetSwapIntervalMESA_ptr)(void);
+    fn_glXGetSwapIntervalMESA_ptr pglXGetSwapIntervalMESA;
+    __GLXvendorInfo *dd = NULL;
+    int ret = 0;
+
+
+    if (!__VND.getCurrentContext()) {
+        return GLX_BAD_CONTEXT;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pglXGetSwapIntervalMESA = (fn_glXGetSwapIntervalMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXGetSwapIntervalMESA]) :
+        NULL);
+    if (pglXGetSwapIntervalMESA) {
+        ret = (*pglXGetSwapIntervalMESA)();
+    }
+
+    return ret;
+
+}
+
+
+
+static Bool dispatch_glXGetSyncValuesOML(Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc)
+{
+
+    typedef Bool (*fn_glXGetSyncValuesOML_ptr)(Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc);
+    fn_glXGetSyncValuesOML_ptr pglXGetSyncValuesOML;
+    __GLXvendorInfo *dd = NULL;
+    Bool ret = False;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXGetSyncValuesOML = (fn_glXGetSyncValuesOML_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXGetSyncValuesOML]) :
+        NULL);
+    if (pglXGetSyncValuesOML) {
+        ret = (*pglXGetSyncValuesOML)(dpy, drawable, ust, msc, sbc);
+    }
+
+    return ret;
+
+}
+
+
+
+static void dispatch_glXJoinSwapGroupSGIX(Display * dpy, GLXDrawable drawable, GLXDrawable member)
+{
+
+    typedef void (*fn_glXJoinSwapGroupSGIX_ptr)(Display * dpy, GLXDrawable drawable, GLXDrawable member);
+    fn_glXJoinSwapGroupSGIX_ptr pglXJoinSwapGroupSGIX;
+    __GLXvendorInfo *dd = NULL;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXJoinSwapGroupSGIX = (fn_glXJoinSwapGroupSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXJoinSwapGroupSGIX]) :
+        NULL);
+    if (pglXJoinSwapGroupSGIX) {
+        (*pglXJoinSwapGroupSGIX)(dpy, drawable, member);
+    }
+
+}
+
+
+
+static Bool dispatch_glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int * value)
+{
+
+    typedef Bool (*fn_glXQueryCurrentRendererIntegerMESA_ptr)(int attribute, unsigned int * value);
+    fn_glXQueryCurrentRendererIntegerMESA_ptr pglXQueryCurrentRendererIntegerMESA;
+    __GLXvendorInfo *dd = NULL;
+    Bool ret = False;
+
+
+    if (!__VND.getCurrentContext()) {
+        return ret;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pglXQueryCurrentRendererIntegerMESA = (fn_glXQueryCurrentRendererIntegerMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXQueryCurrentRendererIntegerMESA]) :
+        NULL);
+    if (pglXQueryCurrentRendererIntegerMESA) {
+        ret = (*pglXQueryCurrentRendererIntegerMESA)(attribute, value);
+    }
+
+    return ret;
+
+}
+
+
+
+static const char * dispatch_glXQueryCurrentRendererStringMESA(int attribute)
+{
+
+    typedef const char * (*fn_glXQueryCurrentRendererStringMESA_ptr)(int attribute);
+    fn_glXQueryCurrentRendererStringMESA_ptr pglXQueryCurrentRendererStringMESA;
+    __GLXvendorInfo *dd = NULL;
+    const char * ret = NULL;
+
+
+    if (!__VND.getCurrentContext()) {
+        return ret;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pglXQueryCurrentRendererStringMESA = (fn_glXQueryCurrentRendererStringMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXQueryCurrentRendererStringMESA]) :
+        NULL);
+    if (pglXQueryCurrentRendererStringMESA) {
+        ret = (*pglXQueryCurrentRendererStringMESA)(attribute);
+    }
+
+    return ret;
+
+}
+
+
+
+static Bool dispatch_glXQueryMaxSwapBarriersSGIX(Display * dpy, int screen, int * max)
+{
+
+    typedef Bool (*fn_glXQueryMaxSwapBarriersSGIX_ptr)(Display * dpy, int screen, int * max);
+    fn_glXQueryMaxSwapBarriersSGIX_ptr pglXQueryMaxSwapBarriersSGIX;
+    __GLXvendorInfo *dd = NULL;
+    Bool ret = False;
+
+
+    dd = __VND.getDynDispatch(dpy, screen);
+    pglXQueryMaxSwapBarriersSGIX = (fn_glXQueryMaxSwapBarriersSGIX_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXQueryMaxSwapBarriersSGIX]) :
+        NULL);
+    if (pglXQueryMaxSwapBarriersSGIX) {
+        ret = (*pglXQueryMaxSwapBarriersSGIX)(dpy, screen, max);
+    }
+
+    return ret;
+
+}
+
+
+
+static Bool dispatch_glXQueryRendererIntegerMESA(Display * dpy, int screen, int renderer, int attribute, unsigned int * value)
+{
+
+    typedef Bool (*fn_glXQueryRendererIntegerMESA_ptr)(Display * dpy, int screen, int renderer, int attribute, unsigned int * value);
+    fn_glXQueryRendererIntegerMESA_ptr pglXQueryRendererIntegerMESA;
+    __GLXvendorInfo *dd = NULL;
+    Bool ret = False;
+
+
+    dd = __VND.getDynDispatch(dpy, screen);
+    pglXQueryRendererIntegerMESA = (fn_glXQueryRendererIntegerMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXQueryRendererIntegerMESA]) :
+        NULL);
+    if (pglXQueryRendererIntegerMESA) {
+        ret = (*pglXQueryRendererIntegerMESA)(dpy, screen, renderer, attribute, value);
+    }
+
+    return ret;
+
+}
+
+
+
+static const char * dispatch_glXQueryRendererStringMESA(Display * dpy, int screen, int renderer, int attribute)
+{
+
+    typedef const char * (*fn_glXQueryRendererStringMESA_ptr)(Display * dpy, int screen, int renderer, int attribute);
+    fn_glXQueryRendererStringMESA_ptr pglXQueryRendererStringMESA;
+    __GLXvendorInfo *dd = NULL;
+    const char * ret = NULL;
+
+
+    dd = __VND.getDynDispatch(dpy, screen);
+    pglXQueryRendererStringMESA = (fn_glXQueryRendererStringMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXQueryRendererStringMESA]) :
+        NULL);
+    if (pglXQueryRendererStringMESA) {
+        ret = (*pglXQueryRendererStringMESA)(dpy, screen, renderer, attribute);
+    }
+
+    return ret;
+
+}
+
+
+
+static Bool dispatch_glXReleaseBuffersMESA(Display * dpy, GLXDrawable d)
+{
+
+    typedef Bool (*fn_glXReleaseBuffersMESA_ptr)(Display * dpy, GLXDrawable d);
+    fn_glXReleaseBuffersMESA_ptr pglXReleaseBuffersMESA;
+    __GLXvendorInfo *dd = NULL;
+    Bool ret = False;
+
+
+    GetDispatchFromDrawable(dpy, d, NULL, &dd);
+    pglXReleaseBuffersMESA = (fn_glXReleaseBuffersMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXReleaseBuffersMESA]) :
+        NULL);
+    if (pglXReleaseBuffersMESA) {
+        ret = (*pglXReleaseBuffersMESA)(dpy, d);
+    }
+
+    return ret;
+
+}
+
+
+
+static int64_t dispatch_glXSwapBuffersMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder)
+{
+
+    typedef int64_t (*fn_glXSwapBuffersMscOML_ptr)(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
+    fn_glXSwapBuffersMscOML_ptr pglXSwapBuffersMscOML;
+    __GLXvendorInfo *dd = NULL;
+    int64_t ret = 0;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXSwapBuffersMscOML = (fn_glXSwapBuffersMscOML_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXSwapBuffersMscOML]) :
+        NULL);
+    if (pglXSwapBuffersMscOML) {
+        ret = (*pglXSwapBuffersMscOML)(dpy, drawable, target_msc, divisor, remainder);
+    }
+
+    return ret;
+
+}
+
+
+
+static int dispatch_glXSwapIntervalMESA(unsigned int interval)
+{
+
+    typedef int (*fn_glXSwapIntervalMESA_ptr)(unsigned int interval);
+    fn_glXSwapIntervalMESA_ptr pglXSwapIntervalMESA;
+    __GLXvendorInfo *dd = NULL;
+    int ret = 0;
+
+
+    if (!__VND.getCurrentContext()) {
+        return GLX_BAD_CONTEXT;
+    }
+
+    dd = __VND.getCurrentDynDispatch();
+    pglXSwapIntervalMESA = (fn_glXSwapIntervalMESA_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXSwapIntervalMESA]) :
+        NULL);
+    if (pglXSwapIntervalMESA) {
+        ret = (*pglXSwapIntervalMESA)(interval);
+    }
+
+    return ret;
+
+}
+
+
+
+static Bool dispatch_glXWaitForMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc)
+{
+
+    typedef Bool (*fn_glXWaitForMscOML_ptr)(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc);
+    fn_glXWaitForMscOML_ptr pglXWaitForMscOML;
+    __GLXvendorInfo *dd = NULL;
+    Bool ret = False;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXWaitForMscOML = (fn_glXWaitForMscOML_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXWaitForMscOML]) :
+        NULL);
+    if (pglXWaitForMscOML) {
+        ret = (*pglXWaitForMscOML)(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
+    }
+
+    return ret;
+
+}
+
+
+
+static Bool dispatch_glXWaitForSbcOML(Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc)
+{
+
+    typedef Bool (*fn_glXWaitForSbcOML_ptr)(Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc);
+    fn_glXWaitForSbcOML_ptr pglXWaitForSbcOML;
+    __GLXvendorInfo *dd = NULL;
+    Bool ret = False;
+
+
+    GetDispatchFromDrawable(dpy, drawable, NULL, &dd);
+    pglXWaitForSbcOML = (fn_glXWaitForSbcOML_ptr)(dd ?
+        __VND.fetchDispatchEntry(dd,
+             __glXDispatchTableIndices[DI_glXWaitForSbcOML]) :
+        NULL);
+    if (pglXWaitForSbcOML) {
+        ret = (*pglXWaitForSbcOML)(dpy, drawable, target_sbc, ust, msc, sbc);
+    }
+
+    return ret;
+
+}
+
+
+
+void __glXGLVNDInitDispatchFunctions(void)
+{
+
+    __glXDispatchFunctions[DI_BindTexImageEXT] = (void *)dispatch_BindTexImageEXT;
+    __glXDispatchFunctions[DI_ChooseFBConfigSGIX] = (void *)dispatch_ChooseFBConfigSGIX;
+    __glXDispatchFunctions[DI_CreateContextAttribsARB] = (void *)dispatch_CreateContextAttribsARB;
+    __glXDispatchFunctions[DI_CreateContextWithConfigSGIX] = (void *)dispatch_CreateContextWithConfigSGIX;
+    __glXDispatchFunctions[DI_CreateGLXPbufferSGIX] = (void *)dispatch_CreateGLXPbufferSGIX;
+    __glXDispatchFunctions[DI_CreateGLXPixmapWithConfigSGIX] = (void *)dispatch_CreateGLXPixmapWithConfigSGIX;
+    __glXDispatchFunctions[DI_DestroyGLXPbufferSGIX] = (void *)dispatch_DestroyGLXPbufferSGIX;
+    __glXDispatchFunctions[DI_FreeContextEXT] = (void *)dispatch_FreeContextEXT;
+    __glXDispatchFunctions[DI_GetContextIDEXT] = (void *)dispatch_GetContextIDEXT;
+    __glXDispatchFunctions[DI_GetCurrentDisplayEXT] = (void *)dispatch_GetCurrentDisplayEXT;
+    __glXDispatchFunctions[DI_GetFBConfigAttribSGIX] = (void *)dispatch_GetFBConfigAttribSGIX;
+    __glXDispatchFunctions[DI_GetFBConfigFromVisualSGIX] = (void *)dispatch_GetFBConfigFromVisualSGIX;
+    __glXDispatchFunctions[DI_GetSelectedEventSGIX] = (void *)dispatch_GetSelectedEventSGIX;
+#if defined(GLX_SGI_video_sync)
+    __glXDispatchFunctions[DI_GetVideoSyncSGI] = (void *)dispatch_GetVideoSyncSGI;
+#endif // defined(GLX_SGI_video_sync)
+    __glXDispatchFunctions[DI_GetVisualFromFBConfigSGIX] = (void *)dispatch_GetVisualFromFBConfigSGIX;
+    __glXDispatchFunctions[DI_ImportContextEXT] = (void *)dispatch_ImportContextEXT;
+    __glXDispatchFunctions[DI_QueryContextInfoEXT] = (void *)dispatch_QueryContextInfoEXT;
+    __glXDispatchFunctions[DI_QueryGLXPbufferSGIX] = (void *)dispatch_QueryGLXPbufferSGIX;
+    __glXDispatchFunctions[DI_ReleaseTexImageEXT] = (void *)dispatch_ReleaseTexImageEXT;
+    __glXDispatchFunctions[DI_SelectEventSGIX] = (void *)dispatch_SelectEventSGIX;
+#if defined(GLX_SGI_swap_control)
+    __glXDispatchFunctions[DI_SwapIntervalSGI] = (void *)dispatch_SwapIntervalSGI;
+#endif // defined(GLX_SGI_swap_control)
+#if defined(GLX_SGI_video_sync)
+    __glXDispatchFunctions[DI_WaitVideoSyncSGI] = (void *)dispatch_WaitVideoSyncSGI;
+#endif // defined(GLX_SGI_video_sync)
+    __glXDispatchFunctions[DI_glXBindSwapBarrierSGIX] = (void *)dispatch_glXBindSwapBarrierSGIX;
+    __glXDispatchFunctions[DI_glXCopySubBufferMESA] = (void *)dispatch_glXCopySubBufferMESA;
+    __glXDispatchFunctions[DI_glXCreateGLXPixmapMESA] = (void *)dispatch_glXCreateGLXPixmapMESA;
+    __glXDispatchFunctions[DI_glXGetMscRateOML] = (void *)dispatch_glXGetMscRateOML;
+    __glXDispatchFunctions[DI_glXGetScreenDriver] = (void *)dispatch_glXGetScreenDriver;
+    __glXDispatchFunctions[DI_glXGetSwapIntervalMESA] = (void *)dispatch_glXGetSwapIntervalMESA;
+    __glXDispatchFunctions[DI_glXGetSyncValuesOML] = (void *)dispatch_glXGetSyncValuesOML;
+    __glXDispatchFunctions[DI_glXJoinSwapGroupSGIX] = (void *)dispatch_glXJoinSwapGroupSGIX;
+    __glXDispatchFunctions[DI_glXQueryCurrentRendererIntegerMESA] = (void *)dispatch_glXQueryCurrentRendererIntegerMESA;
+    __glXDispatchFunctions[DI_glXQueryCurrentRendererStringMESA] = (void *)dispatch_glXQueryCurrentRendererStringMESA;
+    __glXDispatchFunctions[DI_glXQueryMaxSwapBarriersSGIX] = (void *)dispatch_glXQueryMaxSwapBarriersSGIX;
+    __glXDispatchFunctions[DI_glXQueryRendererIntegerMESA] = (void *)dispatch_glXQueryRendererIntegerMESA;
+    __glXDispatchFunctions[DI_glXQueryRendererStringMESA] = (void *)dispatch_glXQueryRendererStringMESA;
+    __glXDispatchFunctions[DI_glXReleaseBuffersMESA] = (void *)dispatch_glXReleaseBuffersMESA;
+    __glXDispatchFunctions[DI_glXSwapBuffersMscOML] = (void *)dispatch_glXSwapBuffersMscOML;
+    __glXDispatchFunctions[DI_glXSwapIntervalMESA] = (void *)dispatch_glXSwapIntervalMESA;
+    __glXDispatchFunctions[DI_glXWaitForMscOML] = (void *)dispatch_glXWaitForMscOML;
+    __glXDispatchFunctions[DI_glXWaitForSbcOML] = (void *)dispatch_glXWaitForSbcOML;
+
+}
+
diff --git a/src/glx/g_glxglvnddispatchindices.h b/src/glx/g_glxglvnddispatchindices.h
new file mode 100644
index 0000000..3c8b0c1
--- /dev/null
+++ b/src/glx/g_glxglvnddispatchindices.h
@@ -0,0 +1,98 @@
+/*
+ * THIS FILE IS AUTOMATICALLY GENERATED BY gen_scrn_dispatch.pl
+ * DO NOT EDIT!!
+ */
+#ifndef __glxlibglvnd_dispatchindex_h__
+#define __glxlibglvnd_dispatchindex_h__
+
+typedef enum __GLXdispatchIndex {
+    DI_BindTexImageEXT,
+    // ChooseFBConfig implemented by libglvnd
+    DI_ChooseFBConfigSGIX,
+    // ChooseVisual implemented by libglvnd
+    // CopyContext implemented by libglvnd
+    // CreateContext implemented by libglvnd
+    DI_CreateContextAttribsARB,
+    DI_CreateContextWithConfigSGIX,
+    DI_CreateGLXPbufferSGIX,
+    // CreateGLXPixmap implemented by libglvnd
+    DI_CreateGLXPixmapWithConfigSGIX,
+    // CreateNewContext implemented by libglvnd
+    // CreatePbuffer implemented by libglvnd
+    // CreatePixmap implemented by libglvnd
+    // CreateWindow implemented by libglvnd
+    // DestroyContext implemented by libglvnd
+    DI_DestroyGLXPbufferSGIX,
+    // DestroyGLXPixmap implemented by libglvnd
+    // DestroyPbuffer implemented by libglvnd
+    // DestroyPixmap implemented by libglvnd
+    // DestroyWindow implemented by libglvnd
+    DI_FreeContextEXT,
+    // GetClientString implemented by libglvnd
+    // GetConfig implemented by libglvnd
+    DI_GetContextIDEXT,
+    // GetCurrentContext implemented by libglvnd
+    // GetCurrentDisplay implemented by libglvnd
+    DI_GetCurrentDisplayEXT,
+    // GetCurrentDrawable implemented by libglvnd
+    // GetCurrentReadDrawable implemented by libglvnd
+    // GetFBConfigAttrib implemented by libglvnd
+    DI_GetFBConfigAttribSGIX,
+    DI_GetFBConfigFromVisualSGIX,
+    // GetFBConfigs implemented by libglvnd
+    // GetProcAddress implemented by libglvnd
+    // GetProcAddressARB implemented by libglvnd
+    // GetSelectedEvent implemented by libglvnd
+    DI_GetSelectedEventSGIX,
+#if defined(GLX_SGI_video_sync)
+    DI_GetVideoSyncSGI,
+#endif // defined(GLX_SGI_video_sync)
+    // GetVisualFromFBConfig implemented by libglvnd
+    DI_GetVisualFromFBConfigSGIX,
+    DI_ImportContextEXT,
+    // IsDirect implemented by libglvnd
+    // MakeContextCurrent implemented by libglvnd
+    // MakeCurrent implemented by libglvnd
+    // QueryContext implemented by libglvnd
+    DI_QueryContextInfoEXT,
+    // QueryDrawable implemented by libglvnd
+    // QueryExtension implemented by libglvnd
+    // QueryExtensionsString implemented by libglvnd
+    DI_QueryGLXPbufferSGIX,
+    // QueryServerString implemented by libglvnd
+    // QueryVersion implemented by libglvnd
+    DI_ReleaseTexImageEXT,
+    // SelectEvent implemented by libglvnd
+    DI_SelectEventSGIX,
+    // SwapBuffers implemented by libglvnd
+#if defined(GLX_SGI_swap_control)
+    DI_SwapIntervalSGI,
+#endif // defined(GLX_SGI_swap_control)
+    // UseXFont implemented by libglvnd
+    // WaitGL implemented by libglvnd
+#if defined(GLX_SGI_video_sync)
+    DI_WaitVideoSyncSGI,
+#endif // defined(GLX_SGI_video_sync)
+    // WaitX implemented by libglvnd
+    DI_glXBindSwapBarrierSGIX,
+    DI_glXCopySubBufferMESA,
+    DI_glXCreateGLXPixmapMESA,
+    DI_glXGetMscRateOML,
+    DI_glXGetScreenDriver,
+    DI_glXGetSwapIntervalMESA,
+    DI_glXGetSyncValuesOML,
+    DI_glXJoinSwapGroupSGIX,
+    DI_glXQueryCurrentRendererIntegerMESA,
+    DI_glXQueryCurrentRendererStringMESA,
+    DI_glXQueryMaxSwapBarriersSGIX,
+    DI_glXQueryRendererIntegerMESA,
+    DI_glXQueryRendererStringMESA,
+    DI_glXReleaseBuffersMESA,
+    DI_glXSwapBuffersMscOML,
+    DI_glXSwapIntervalMESA,
+    DI_glXWaitForMscOML,
+    DI_glXWaitForSbcOML,
+    DI_LAST_INDEX
+} __GLXdispatchIndex;
+
+#endif // __glxlibglvnd_dispatchindex_h__
diff --git a/src/glx/glxcmds.c b/src/glx/glxcmds.c
index 2aef4d9..211a0c4 100644
--- a/src/glx/glxcmds.c
+++ b/src/glx/glxcmds.c
@@ -2644,7 +2644,7 @@ _GLX_PUBLIC void (*glXGetProcAddressARB(const GLubyte * procName)) (void)
  *
  * \sa glXGetProcAddressARB
  */
-_X_EXPORT void (*glXGetProcAddress(const GLubyte * procName)) (void)
+_GLX_PUBLIC void (*glXGetProcAddress(const GLubyte * procName)) (void)
 #if defined(__GNUC__) && !defined(GLX_ALIAS_UNSUPPORTED)
 # if defined(USE_MGL_NAMESPACE)
    __attribute__ ((alias("mglXGetProcAddressARB")));
diff --git a/src/glx/glxglvnd.c b/src/glx/glxglvnd.c
new file mode 100644
index 0000000..94dea70
--- /dev/null
+++ b/src/glx/glxglvnd.c
@@ -0,0 +1,94 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <dlfcn.h>
+
+#include <X11/Xlib.h>
+#include <X11/Xlibint.h>
+
+#include "glx_error.h"
+#include "libglxabi.h"
+#include "glxglvnd.h"
+
+#include <assert.h>
+
+_X_EXPORT __GLX_MAIN_PROTO(version, exports, vendorName);
+
+static Bool initDone = False;
+
+static Bool __glXGLVNDSupportsScreen(Display *dpy, int screen)
+{
+    return True;
+}
+
+static void *__glXGLVNDGetProcAddress(const GLubyte *procName)
+{
+    return glXGetProcAddressARB(procName);
+}
+
+static int FindGLXFunction(const GLubyte *name)
+{
+    int i;
+    for (i=0; i<DI_FUNCTION_COUNT; i++)
+    {
+        if (strcmp((const char *) name, __glXDispatchTableStrings[i]) == 0)
+        {
+            return i;
+        }
+    }
+    return -1;
+}
+
+static void *__glXGLVNDGetDispatchAddress(const GLubyte *procName)
+{
+    int internalIndex = FindGLXFunction(procName);
+    if (internalIndex >= 0)
+    {
+        return __glXDispatchFunctions[internalIndex];
+    }
+    return NULL;
+}
+
+static void __glXGLVNDSetDispatchIndex(const GLubyte *procName, int index)
+{
+    int internalIndex = FindGLXFunction(procName);
+    if (internalIndex >= 0)
+    {
+        __glXDispatchTableIndices[internalIndex] = index;
+    }
+}
+
+static void __glXGLVNDNotifyError(Display *dpy, char error, char opcode, XID resid)
+{
+    __glXSendError(dpy, error, resid, opcode, True);
+}
+
+static __GLXapiImports glvndImports =
+{
+    __glXGLVNDSupportsScreen, // checkSupportsScreen
+    __glXGLVNDGetProcAddress, // getProcAddress
+    __glXGLVNDGetDispatchAddress, // getDispatchAddress
+    __glXGLVNDSetDispatchIndex, // setDispatchIndex
+    __glXGLVNDNotifyError, // notifyError
+    NULL // patchCallbacks
+};
+
+__GLX_MAIN_PROTO(version, exports, vendorName)
+{
+
+    if (version != GLX_VENDOR_ABI_VERSION)
+    {
+        return NULL;
+    }
+
+    if (!initDone)
+    {
+        initDone = True;
+        __glXGLVNDInitDispatchFunctions();
+        memcpy(&__glXGLVNDAPIExports, exports, sizeof(*exports));
+    }
+
+    return &glvndImports;
+}
+
diff --git a/src/glx/glxglvnd.h b/src/glx/glxglvnd.h
new file mode 100644
index 0000000..4370a3a
--- /dev/null
+++ b/src/glx/glxglvnd.h
@@ -0,0 +1,24 @@
+#ifndef _glx_lib_glvnd_h_
+#define _glx_lib_glvnd_h_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#include "libglxabi.h"
+
+extern __GLXapiExports __glXGLVNDAPIExports;
+
+extern const int DI_FUNCTION_COUNT;
+
+extern void *__glXDispatchFunctions[];
+extern int __glXDispatchTableIndices[];
+extern const char *__glXDispatchTableStrings[];
+
+extern void __glXGLVNDInitDispatchFunctions(void);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff --git a/src/glx/glxglvnddispatchfuncs.h b/src/glx/glxglvnddispatchfuncs.h
new file mode 100644
index 0000000..9d3a182
--- /dev/null
+++ b/src/glx/glxglvnddispatchfuncs.h
@@ -0,0 +1,113 @@
+#ifndef __glx_glvnd_dispatch_funcs_h__
+#define __glx_glvnd_dispatch_funcs_h__
+/*
+ * Helper functions used by g_glxglvnddispatchfuncs.c.
+ */
+#include "glxglvnd.h"
+#include <assert.h>
+
+#define __VND __glXGLVNDAPIExports
+
+static inline int GET_CURRENT_SCREEN(void)
+{
+    GLXContext context = __VND.getCurrentContext();
+    int screen = -1;
+
+    if (!context) {
+        return -1;
+    }
+
+    __VND.vendorFromContext(glXGetCurrentDisplay(), context, &screen, NULL);
+    assert(screen >= 0);
+
+    return screen;
+}
+
+static inline int GET_DEFAULT_SCREEN(void)
+{
+    return 0;
+}
+
+#define GET_CURRENT_DISPLAY() glXGetCurrentDisplay()
+
+static inline Display *GET_DEFAULT_DISPLAY(void)
+{
+    // TODO think of a better heuristic...
+    assert(!"GET_DEFAULT_DISPLAY() called");
+    return GET_CURRENT_DISPLAY();
+}
+
+static inline void AddFBConfigMapping(Display *dpy, GLXFBConfig config,
+                                             int screen, __GLXvendorInfo *vendor)
+{
+    __VND.addScreenFBConfigMapping(dpy, config, screen, vendor);
+}
+
+static inline void AddScreenFBConfigsMapping(Display *dpy, const GLXFBConfig *ret,
+                                             int *nelements,
+                                             int screen, __GLXvendorInfo *vendor)
+{
+    int i;
+    if (!nelements || !ret) {
+        return;
+    }
+
+    for (i = 0; i < *nelements; i++) {
+        __VND.addScreenFBConfigMapping(dpy, ret[i], screen, vendor);
+    }
+}
+
+static inline void AddVisualMapping(Display *dpy, const XVisualInfo *visual,
+        __GLXvendorInfo *vendor)
+{
+    __VND.addScreenVisualMapping(dpy, visual, vendor);
+}
+
+static inline void AddDrawableMapping(Display *dpy, GLXDrawable drawable,
+        int screen, __GLXvendorInfo *vendor)
+{
+    __VND.addScreenDrawableMapping(dpy, drawable, screen, vendor);
+}
+
+static inline void AddContextMapping(Display *dpy, GLXContext ctx,
+        int screen, __GLXvendorInfo *vendor)
+{
+    __VND.addScreenContextMapping(dpy, ctx, screen, vendor);
+}
+
+static inline void GetDispatchFromDrawable(Display *dpy, GLXDrawable drawable,
+        int *retScreen, __GLXvendorInfo **retVendor)
+{
+    __VND.vendorFromDrawable(dpy, drawable, retScreen, retVendor);
+}
+
+static inline void GetDispatchFromContext(Display *dpy, GLXContext ctx,
+        int *retScreen, __GLXvendorInfo **retVendor)
+{
+    __VND.vendorFromContext(dpy, ctx, retScreen, retVendor);
+}
+
+static inline __GLXvendorInfo *GetDispatchFromMultiContext(Display *dpy, GLXContext ctx1, GLXContext ctx2)
+{
+    __GLXvendorInfo *vendor = NULL;
+    if (__VND.vendorFromContext(dpy, ctx1, NULL, &vendor) == 0) {
+        return vendor;
+    }
+    if (__VND.vendorFromContext(dpy, ctx2, NULL, &vendor) == 0) {
+        return vendor;
+    }
+    return __VND.getCurrentDynDispatch();
+}
+
+static inline void GetDispatchFromFBConfig(Display *dpy, GLXFBConfig config,
+        int *retScreen, __GLXvendorInfo **retVendor)
+{
+    __VND.vendorFromFBConfig(dpy, config, retScreen, retVendor);
+}
+
+static inline void GetDispatchFromVisual(Display *dpy, const XVisualInfo *visual, __GLXvendorInfo **retVendor)
+{
+    __VND.vendorFromVisual(dpy, visual, retVendor);
+}
+
+#endif // __glx_glvnd_dispatch_funcs_h__
-- 
2.7.0

