From de346adad77d49d7e8f9220512fff6caf72eff05 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Samuel=20Iglesias=20Gons=C3=A1lvez?= <siglesias@igalia.com>
Date: Mon, 13 Feb 2017 13:24:18 +0100
Subject: [PATCH 25/31] i965/fs: fix indirect load DF uniforms on BSW/BXT
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Previously we were emitting two MOV_INDIRECT instructions by calculating
source's indirect offsets for each 32-bit half of a DF source. However,
this is not needed as we can just emit two 32-bit MOV INDIRECT without
doing that calculation.

Signed-off-by: Samuel Iglesias Gons√°lvez <siglesias@igalia.com>
Cc: "17.0" <mesa-stable@lists.freedesktop.org>
---
 src/mesa/drivers/dri/i965/brw_fs_nir.cpp | 23 ++++++++++-------------
 1 file changed, 10 insertions(+), 13 deletions(-)

diff --git a/src/mesa/drivers/dri/i965/brw_fs_nir.cpp b/src/mesa/drivers/dri/i965/brw_fs_nir.cpp
index 991c20fad62..8975940e10b 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_nir.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_nir.cpp
@@ -3878,31 +3878,28 @@ fs_visitor::nir_emit_intrinsic(const fs_builder &bld, nir_intrinsic_instr *instr
          unsigned read_size = instr->const_index[1] -
             (instr->num_components - 1) * type_sz(dest.type);
 
-         fs_reg indirect_chv_high_32bit;
-         bool is_chv_bxt_64bit =
-            (devinfo->is_cherryview || devinfo->is_broxton) &&
-            type_sz(dest.type) == 8;
-         if (is_chv_bxt_64bit) {
-            indirect_chv_high_32bit = vgrf(glsl_type::uint_type);
-            /* Calculate indirect address to read high 32 bits */
-            bld.ADD(indirect_chv_high_32bit, indirect, brw_imm_ud(4));
-         }
+         bool supports_64bit_indirects =
+            !devinfo->is_cherryview && !devinfo->is_broxton;
 
          for (unsigned j = 0; j < instr->num_components; j++) {
-            if (!is_chv_bxt_64bit) {
+            if (type_sz(dest.type) != 8 || supports_64bit_indirects) {
                bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                         offset(dest, bld, j), offset(src, bld, j),
                         indirect, brw_imm_ud(read_size));
             } else {
+               /* We are going to read 64-bit data in two 32-bit MOV INDIRECTS,
+                * each one reading half of the data.
+                */
+               read_size /= 2;
                bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                         subscript(offset(dest, bld, j), BRW_REGISTER_TYPE_UD, 0),
-                        offset(src, bld, j),
+                        subscript(offset(src, bld, j), BRW_REGISTER_TYPE_UD, 0),
                         indirect, brw_imm_ud(read_size));
 
                bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                         subscript(offset(dest, bld, j), BRW_REGISTER_TYPE_UD, 1),
-                        offset(src, bld, j),
-                        indirect_chv_high_32bit, brw_imm_ud(read_size));
+                        subscript(offset(src, bld, j), BRW_REGISTER_TYPE_UD, 1),
+                        indirect, brw_imm_ud(read_size));
             }
          }
       }
-- 
2.11.1

