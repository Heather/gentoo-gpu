From 33f89d6510681c49a0ae3cb9e81b488f7b014da6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Samuel=20Iglesias=20Gons=C3=A1lvez?= <siglesias@igalia.com>
Date: Thu, 9 Mar 2017 11:26:53 +0100
Subject: [PATCH 08/31] MERGE generalize d2x to all instructions: legalize by
 default.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Samuel Iglesias Gons√°lvez <siglesias@igalia.com>
---
 src/intel/compiler/brw_fs_lower_d2x.cpp | 119 ++++++++++++++++++++++++--------
 1 file changed, 90 insertions(+), 29 deletions(-)

diff --git a/src/intel/compiler/brw_fs_lower_d2x.cpp b/src/intel/compiler/brw_fs_lower_d2x.cpp
index f9e5ee57361..33e1b9391e2 100644
--- a/src/intel/compiler/brw_fs_lower_d2x.cpp
+++ b/src/intel/compiler/brw_fs_lower_d2x.cpp
@@ -56,7 +56,16 @@ fs_visitor::lower_d2x()
        */
       if (supported_conversion ||
           (!inst_support_conversion && inst->dst.type == inst->src[0].type) ||
-          inst->dst.file == BAD_FILE)
+          inst->dst.file == BAD_FILE || inst->src[0].file == BAD_FILE)
+         continue;
+
+      /* This pass only supports conversion to narrower or equal size types. */
+      if (get_exec_type_size(inst) < type_sz(inst->dst.type))
+          continue;
+
+      /* If the source types are mixed, we don't lower it. */
+      if ((inst->src[1].file != BAD_FILE && inst->src[1].type != inst->src[0].type) ||
+          (inst->src[2].file != BAD_FILE && inst->src[2].type != inst->src[0].type))
          continue;
 
       assert(inst->saturate == false);
@@ -64,30 +73,17 @@ fs_visitor::lower_d2x()
       const fs_builder ibld(this, block, inst);
       fs_reg dst = inst->dst;
 
-      /* From the Broadwell PRM, 3D Media GPGPU, "Double Precision Float to
-       * Single Precision Float":
-       *
-       *    The upper Dword of every Qword will be written with undefined
-       *    value when converting DF to F.
-       *
-       * So we need to allocate a temporary that's two registers, and then do
-       * a strided MOV to get the lower DWord of every Qword that has the
-       * result.
-       *
-       * This pass legalizes all the DF conversions to narrower types.
-       */
-      switch (inst->opcode) {
-      case BRW_OPCODE_BFE:
-      case BRW_OPCODE_BFI2:
-         /* BFE/BFI2 emitter might have mixed D and UD types
-          * and could want us to ignore that and use the destination type.
-          * This is going to be fixed in brw_alu3() at brw_eu_emit.c.
+      if (inst_support_conversion && !supported_conversion) {
+         /* From the Broadwell PRM, 3D Media GPGPU, "Double Precision Float to
+          * Single Precision Float":
+          *
+          *    The upper Dword of every Qword will be written with undefined
+          *    value when converting DF to F.
+          *
+          * So we need to allocate a temporary that's two registers, and then do
+          * a strided MOV to get the lower DWord of every Qword that has the
+          * result.
           */
-         assert(dst.type == BRW_REGISTER_TYPE_D || dst.type == BRW_REGISTER_TYPE_UD);
-         assert(get_exec_type_size(inst) == 4);
-         continue;
-      case SHADER_OPCODE_MOV_INDIRECT:
-      case BRW_OPCODE_MOV: {
          fs_reg temp = ibld.vgrf(inst->src[0].type, 1);
          fs_reg strided_temp = subscript(temp, dst.type, 0);
 
@@ -101,9 +97,77 @@ fs_visitor::lower_d2x()
           */
          inst->size_written = inst->dst.component_size(inst->exec_size);
          ibld.at(block, inst->next).MOV(dst, strided_temp);
-         break;
+         progress = true;
+         continue;
       }
-      case BRW_OPCODE_SEL: {
+
+      switch (inst->opcode) {
+      case BRW_OPCODE_ASR:
+      case BRW_OPCODE_SHR:
+      case BRW_OPCODE_SHL:
+         assert(type_sz(inst->src[1].type) != 8);
+         continue;
+
+      case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN4:
+      case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN7:
+         /* This is not a conversion, it receives a surface index and offset
+          * as sources.
+          */
+         continue;
+
+      case FS_OPCODE_PIXEL_X:
+      case FS_OPCODE_PIXEL_Y:
+         /* They are implemented as MOVs, which is a supported convertion
+          * instruction.
+          */
+         assert(inst->src[0].type == BRW_REGISTER_TYPE_UW);
+         continue;
+
+      case BRW_OPCODE_F16TO32:
+      case BRW_OPCODE_F32TO16:
+      case FS_OPCODE_PACK_HALF_2x16_SPLIT:
+      case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_X:
+      case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_Y:
+         /* They do specific conversions, no need to lower them. */
+         continue;
+
+      case FS_OPCODE_GET_BUFFER_SIZE:
+      case SHADER_OPCODE_TEX:
+      case FS_OPCODE_TXB:
+      case SHADER_OPCODE_TXD:
+      case SHADER_OPCODE_TXF:
+      case SHADER_OPCODE_TXF_LZ:
+      case SHADER_OPCODE_TXF_CMS:
+      case SHADER_OPCODE_TXF_CMS_W:
+      case SHADER_OPCODE_TXF_UMS:
+      case SHADER_OPCODE_TXF_MCS:
+      case SHADER_OPCODE_TXL:
+      case SHADER_OPCODE_TXL_LZ:
+      case SHADER_OPCODE_TXS:
+      case SHADER_OPCODE_LOD:
+      case SHADER_OPCODE_TG4:
+      case SHADER_OPCODE_TG4_OFFSET:
+      case SHADER_OPCODE_SAMPLEINFO:
+      case SHADER_OPCODE_URB_READ_SIMD8:
+      case SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT:
+      case FS_OPCODE_INTERPOLATE_AT_SAMPLE:
+      case FS_OPCODE_INTERPOLATE_AT_SHARED_OFFSET:
+      case FS_OPCODE_INTERPOLATE_AT_PER_SLOT_OFFSET:
+      case FS_OPCODE_FB_READ:
+         /* These opcodes emit messages, so they are not conversions. */
+         continue;
+
+      case BRW_OPCODE_BFE:
+      case BRW_OPCODE_BFI2:
+         /* BFE/BFI2 emitter might have mixed D and UD types
+          * and could want us to ignore that and use the destination type.
+          * This is going to be fixed in brw_alu3() at brw_eu_emit.c.
+          */
+         assert(dst.type == BRW_REGISTER_TYPE_D || dst.type == BRW_REGISTER_TYPE_UD);
+         assert(get_exec_type_size(inst) == 4);
+         continue;
+
+      default: {
          fs_reg temp0 = ibld.vgrf(inst->src[0].type, 1);
          fs_reg temp1 = ibld.vgrf(inst->src[0].type, 1);
          fs_reg strided_temp1 = subscript(temp1, dst.type, 0);
@@ -121,9 +185,6 @@ fs_visitor::lower_d2x()
 
          break;
       }
-      default:
-         assert(get_exec_type_size(inst) != 8);
-         continue;
       }
       progress = true;
    }
-- 
2.11.1

