From 39ae196cb2b787ba019bd5ac2334bd8743be485f Mon Sep 17 00:00:00 2001
From: "Juan A. Suarez Romero" <jasuarez@igalia.com>
Date: Fri, 10 Feb 2017 17:59:26 +0100
Subject: [PATCH 33/37] SQUASH!! i965/vec4: consider subregister offset in live
 variables

Take in account offset values less than a full register (32 bytes) when
getting the var from register.

This is required when dealing with an operation that writes half of the
register (like one d2x in IVB/BYT, which uses exec_size == 4).

- v2: take in account this offset < 32 in liveness analysis too (Curro)
---
 src/mesa/drivers/dri/i965/brw_vec4_live_variables.cpp | 8 ++++----
 src/mesa/drivers/dri/i965/brw_vec4_live_variables.h   | 8 ++++----
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/mesa/drivers/dri/i965/brw_vec4_live_variables.cpp b/src/mesa/drivers/dri/i965/brw_vec4_live_variables.cpp
index 54ebd0994ee..dc1ad21038c 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_live_variables.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_live_variables.cpp
@@ -79,7 +79,7 @@ vec4_live_variables::setup_def_use()
                for (unsigned j = 0; j < DIV_ROUND_UP(inst->size_read(i), 16); j++) {
                   for (int c = 0; c < 4; c++) {
                      const unsigned v =
-                        var_from_reg(alloc, inst->src[i], c, j, false);
+                        var_from_reg(alloc, inst->src[i], c, j);
                      if (!BITSET_TEST(bd->def, v))
                         BITSET_SET(bd->use, v);
                   }
@@ -103,7 +103,7 @@ vec4_live_variables::setup_def_use()
                for (int c = 0; c < 4; c++) {
                   if (inst->dst.writemask & (1 << c)) {
                      const unsigned v =
-                        var_from_reg(alloc, inst->dst, c, i, false);
+                        var_from_reg(alloc, inst->dst, c, i);
                      if (!BITSET_TEST(bd->use, v))
                         BITSET_SET(bd->def, v);
                   }
@@ -260,7 +260,7 @@ vec4_visitor::calculate_live_intervals()
             for (unsigned j = 0; j < DIV_ROUND_UP(inst->size_read(i), 16); j++) {
                for (int c = 0; c < 4; c++) {
                   const unsigned v =
-                     var_from_reg(alloc, inst->src[i], c, j, false);
+                     var_from_reg(alloc, inst->src[i], c, j);
                   start[v] = MIN2(start[v], ip);
                   end[v] = ip;
                }
@@ -273,7 +273,7 @@ vec4_visitor::calculate_live_intervals()
             for (int c = 0; c < 4; c++) {
                if (inst->dst.writemask & (1 << c)) {
                   const unsigned v =
-                     var_from_reg(alloc, inst->dst, c, i, false);
+                     var_from_reg(alloc, inst->dst, c, i);
                   start[v] = MIN2(start[v], ip);
                   end[v] = ip;
                }
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_live_variables.h b/src/mesa/drivers/dri/i965/brw_vec4_live_variables.h
index 9c505d15f1f..b23df650c11 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_live_variables.h
+++ b/src/mesa/drivers/dri/i965/brw_vec4_live_variables.h
@@ -83,14 +83,14 @@ protected:
  */
 inline unsigned
 var_from_reg(const simple_allocator &alloc, const src_reg &reg,
-             unsigned c = 0, unsigned k = 0, bool subreg_precision = true)
+             unsigned c = 0, unsigned k = 0)
 {
    assert(reg.file == VGRF && reg.nr < alloc.count && c < 4);
    const unsigned csize = DIV_ROUND_UP(type_sz(reg.type), 4);
    unsigned result =
       8 * (alloc.offsets[reg.nr] + reg.offset / REG_SIZE) +
       (BRW_GET_SWZ(reg.swizzle, c) + k / csize * 4) * csize + k % csize +
-      (subreg_precision ? (reg.offset % REG_SIZE) / type_sz(reg.type) : 0);
+      (reg.offset % REG_SIZE) / type_sz(reg.type);
    /* Do not exceed the limit for this register */
    assert(result < 8 * (alloc.offsets[reg.nr] + alloc.sizes[reg.nr]));
    return result;
@@ -98,14 +98,14 @@ var_from_reg(const simple_allocator &alloc, const src_reg &reg,
 
 inline unsigned
 var_from_reg(const simple_allocator &alloc, const dst_reg &reg,
-             unsigned c = 0, unsigned k = 0, bool subreg_precision = true)
+             unsigned c = 0, unsigned k = 0)
 {
    assert(reg.file == VGRF && reg.nr < alloc.count && c < 4);
    const unsigned csize = DIV_ROUND_UP(type_sz(reg.type), 4);
    unsigned result =
       8 * (alloc.offsets[reg.nr] + reg.offset / REG_SIZE) +
       (c + k / csize * 4) * csize + k % csize +
-      (subreg_precision ? (reg.offset % REG_SIZE) / type_sz(reg.type) : 0);
+      (reg.offset % REG_SIZE) / type_sz(reg.type);
    /* Do not exceed the limit for this register */
    assert(result < 8 * (alloc.offsets[reg.nr] + alloc.sizes[reg.nr]));
    return result;
-- 
2.11.0

