From 145003dbf176339157792ea4e3d483e36d84bad4 Mon Sep 17 00:00:00 2001
From: Eric Anholt <eric@anholt.net>
Date: Fri, 28 Dec 2012 15:05:34 -0800
Subject: [PATCH 10/29] mesa: Add infrastructure for a worker thread to process
 GL commands.

v2: Keep an allocated buffer around instead of checking for one at the
    start of every GL command.  Inline the now-small space allocation
    function.
v3: Remove duplicate !glthread->shutdown check, process remaining work
    before shutdown.
v4: Fix leaks on destroy.
V5: (Timothy Arceri) fix order of source files in makefile
---
 src/mesa/Makefile.sources |   1 +
 src/mesa/main/context.c   |   3 +
 src/mesa/main/glthread.c  | 228 ++++++++++++++++++++++++++++++++++++++++++++++
 src/mesa/main/glthread.h  | 130 ++++++++++++++++++++++++++
 src/mesa/main/marshal.h   | 112 +++++++++++++++++++++++
 src/mesa/main/mtypes.h    |   2 +
 6 files changed, 476 insertions(+)
 create mode 100644 src/mesa/main/glthread.c
 create mode 100644 src/mesa/main/glthread.h
 create mode 100644 src/mesa/main/marshal.h

diff --git a/src/mesa/Makefile.sources b/src/mesa/Makefile.sources
index 17f84fd0b61..b2d078368a4 100644
--- a/src/mesa/Makefile.sources
+++ b/src/mesa/Makefile.sources
@@ -115,6 +115,7 @@ MAIN_FILES = \
 	main/getstring.c \
 	main/glformats.c \
 	main/glformats.h \
+	main/glthread.c \
 	main/glheader.h \
 	main/hash.c \
 	main/hash.h \
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 8349b88a27b..95a337b14bc 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -100,6 +100,7 @@
 #include "fog.h"
 #include "formats.h"
 #include "framebuffer.h"
+#include "glthread.h"
 #include "hint.h"
 #include "hash.h"
 #include "light.h"
@@ -1293,6 +1294,8 @@ _mesa_free_context_data( struct gl_context *ctx )
       _mesa_make_current(ctx, NULL, NULL);
    }
 
+   _mesa_glthread_destroy(ctx);
+
    /* unreference WinSysDraw/Read buffers */
    _mesa_reference_framebuffer(&ctx->WinSysDrawBuffer, NULL);
    _mesa_reference_framebuffer(&ctx->WinSysReadBuffer, NULL);
diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
new file mode 100644
index 00000000000..76eb0cf7dac
--- /dev/null
+++ b/src/mesa/main/glthread.c
@@ -0,0 +1,228 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/** @file glthread.c
+ *
+ * Support functions for the glthread feature of Mesa.
+ *
+ * In multicore systems, many applications end up CPU-bound with about half
+ * their time spent inside their rendering thread and half inside Mesa.  To
+ * alleviate this, we put a shim layer in Mesa at the GL dispatch level that
+ * quickly logs the GL commands to a buffer to be processed by a worker
+ * thread.
+ */
+
+#include "main/mtypes.h"
+#include "main/glthread.h"
+#include "main/marshal.h"
+#include "main/marshal_generated.h"
+
+#ifdef HAVE_PTHREAD
+
+static void
+glthread_allocate_batch(struct gl_context *ctx)
+{
+   struct glthread_state *glthread = ctx->GLThread;
+
+   /* TODO: handle memory allocation failure. */
+   glthread->batch = calloc(1, sizeof(*glthread->batch));
+   if (!glthread->batch)
+      return;
+   glthread->batch->buffer = malloc(MARSHAL_MAX_CMD_SIZE);
+}
+
+static void
+glthread_unmarshal_batch(struct gl_context *ctx, struct glthread_batch *batch)
+{
+   free(batch->buffer);
+   free(batch);
+}
+
+static void *
+glthread_worker(void *data)
+{
+   struct gl_context *ctx = data;
+   struct glthread_state *glthread = ctx->GLThread;
+
+   ctx->Driver.SetBackgroundContext(ctx);
+   _glapi_set_context(ctx);
+
+   pthread_mutex_lock(&glthread->mutex);
+
+   while (true) {
+      struct glthread_batch *batch;
+
+      /* Block (dropping the lock) until new work arrives for us. */
+      while (!glthread->batch_queue && !glthread->shutdown) {
+         pthread_cond_broadcast(&glthread->work_done);
+         pthread_cond_wait(&glthread->new_work, &glthread->mutex);
+      }
+
+      batch = glthread->batch_queue;
+
+      if (glthread->shutdown && !batch) {
+         pthread_cond_broadcast(&glthread->work_done);
+         pthread_mutex_unlock(&glthread->mutex);
+         return NULL;
+      }
+      glthread->batch_queue = batch->next;
+      if (glthread->batch_queue_tail == &batch->next)
+         glthread->batch_queue_tail = &glthread->batch_queue;
+
+      glthread->busy = true;
+      pthread_mutex_unlock(&glthread->mutex);
+
+      glthread_unmarshal_batch(ctx, batch);
+
+      pthread_mutex_lock(&glthread->mutex);
+      glthread->busy = false;
+   }
+
+   /* UNREACHED */
+   return NULL;
+}
+
+void
+_mesa_glthread_init(struct gl_context *ctx)
+{
+   struct glthread_state *glthread = calloc(1, sizeof(*glthread));
+
+   if (!glthread)
+      return;
+
+   pthread_mutex_init(&glthread->mutex, NULL);
+   pthread_cond_init(&glthread->new_work, NULL);
+   pthread_cond_init(&glthread->work_done, NULL);
+
+   glthread->batch_queue_tail = &glthread->batch_queue;
+   ctx->GLThread = glthread;
+
+   glthread_allocate_batch(ctx);
+
+   pthread_create(&glthread->thread, NULL, glthread_worker, ctx);
+}
+
+void
+_mesa_glthread_destroy(struct gl_context *ctx)
+{
+   struct glthread_state *glthread = ctx->GLThread;
+
+   if (!glthread)
+      return;
+
+   _mesa_glthread_flush_batch(ctx);
+
+   pthread_mutex_lock(&glthread->mutex);
+   glthread->shutdown = true;
+   pthread_cond_broadcast(&glthread->new_work);
+   pthread_mutex_unlock(&glthread->mutex);
+
+   /* Since this waits for the thread to exit, it means that all queued work
+    * will have been completed.
+    */
+   pthread_join(glthread->thread, NULL);
+
+   pthread_cond_destroy(&glthread->new_work);
+   pthread_cond_destroy(&glthread->work_done);
+   pthread_mutex_destroy(&glthread->mutex);
+
+   /* Due to the join above, there should be one empty batch allocated at this
+    * point, and no batches queued.
+    */
+   assert(!glthread->batch->used);
+   assert(!glthread->batch->next);
+   free(glthread->batch);
+   assert(!glthread->batch_queue);
+
+   free(glthread);
+   ctx->GLThread = NULL;
+}
+
+void
+_mesa_glthread_flush_batch(struct gl_context *ctx)
+{
+   struct glthread_state *glthread = ctx->GLThread;
+   struct glthread_batch *batch;
+
+   if (!glthread)
+      return;
+
+   batch = glthread->batch;
+   if (!batch->used)
+      return;
+
+   /* Immediately reallocate a new batch, since the next marshalled call would
+    * just do it.
+    */
+   glthread_allocate_batch(ctx);
+
+   /* Debug: execute the batch immediately from this thread.
+    *
+    * Note that glthread_unmarshal_batch() changes the dispatch table so we'll
+    * need to restore it when it returns.
+    */
+   if (false) {
+      glthread_unmarshal_batch(ctx, batch);
+      return;
+   }
+
+   pthread_mutex_lock(&glthread->mutex);
+   *glthread->batch_queue_tail = batch;
+   glthread->batch_queue_tail = &batch->next;
+   pthread_cond_broadcast(&glthread->new_work);
+   pthread_mutex_unlock(&glthread->mutex);
+}
+
+/**
+ * Waits for all pending batches have been unmarshaled.
+ *
+ * This can be used by the main thread to synchronize access to the context,
+ * since the worker thread will be idle after this.
+ */
+void
+_mesa_glthread_finish(struct gl_context *ctx)
+{
+   struct glthread_state *glthread = ctx->GLThread;
+
+   if (!glthread)
+      return;
+
+   /* If this is called from the worker thread, then we've hit a path that
+    * might be called from either the main thread or the worker (such as some
+    * dri interface entrypoints), in which case we don't need to actually
+    * synchronize against ourself.
+    */
+   if (pthread_self() == glthread->thread)
+      return;
+
+   _mesa_glthread_flush_batch(ctx);
+
+   pthread_mutex_lock(&glthread->mutex);
+
+   while (glthread->batch_queue || glthread->busy)
+      pthread_cond_wait(&glthread->work_done, &glthread->mutex);
+
+   pthread_mutex_unlock(&glthread->mutex);
+}
+
+#endif
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
new file mode 100644
index 00000000000..c38fef32fa0
--- /dev/null
+++ b/src/mesa/main/glthread.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _GLTHREAD_H
+#define _GLTHREAD_H
+
+#ifdef HAVE_PTHREAD
+
+#include <inttypes.h>
+#include <stdbool.h>
+#include <pthread.h>
+#include "main/mtypes.h"
+
+enum marshal_dispatch_cmd_id;
+
+/* Command size is a number of bytes stored in a short. */
+#define MARSHAL_MAX_CMD_SIZE 65535
+
+struct glthread_state
+{
+   /** The worker thread that asynchronously processes our GL commands. */
+   pthread_t thread;
+
+   /**
+    * Mutex used for synchronizing between the main thread and the worker
+    * thread.
+    */
+   pthread_mutex_t mutex;
+
+   /** Condvar used for waking the worker thread. */
+   pthread_cond_t new_work;
+
+   /** Condvar used for waking the main thread. */
+   pthread_cond_t work_done;
+
+   /** Used to tell the worker thread to quit */
+   bool shutdown;
+
+   /** Indicates that the worker thread is currently processing a batch */
+   bool busy;
+
+   /**
+    * Singly-linked list of command batches that are awaiting execution by
+    * a thread pool task.  NULL if empty.
+    */
+   struct glthread_batch *batch_queue;
+
+   /**
+    * Tail pointer for appending batches to the end of batch_queue.  If the
+    * queue is empty, this points to batch_queue.
+    */
+   struct glthread_batch **batch_queue_tail;
+
+   /**
+    * Batch containing commands that are being prepared for insertion into
+    * batch_queue.  NULL if there are no such commands.
+    *
+    * Since this is only used by the main thread, it doesn't need the mutex to
+    * be accessed.
+    */
+   struct glthread_batch *batch;
+};
+
+/**
+ * A single batch of commands queued up for later execution by a thread pool
+ * task.
+ */
+struct glthread_batch
+{
+   /**
+    * Next batch of commands to execute after this batch, or NULL if this is
+    * the last set of commands queued.  Protected by ctx->Marshal.Mutex.
+    */
+   struct glthread_batch *next;
+
+   /**
+    * Points to the first command in the batch.
+    */
+   uint8_t *buffer;
+
+   /**
+    * Amount of data used by batch commands, in bytes.
+    */
+   size_t used;
+};
+
+void _mesa_glthread_init(struct gl_context *ctx);
+void _mesa_glthread_destroy(struct gl_context *ctx);
+
+void _mesa_glthread_flush_batch(struct gl_context *ctx);
+void _mesa_glthread_finish(struct gl_context *ctx);
+
+#else /* HAVE_PTHREAD */
+
+static inline void
+_mesa_glthread_init(struct gl_context *ctx)
+{
+}
+
+static inline void
+_mesa_glthread_destroy(struct gl_context *ctx)
+{
+}
+
+static inline void
+_mesa_glthread_finish(struct gl_context *ctx)
+{
+}
+#endif /* !HAVE_PTHREAD */
+#endif /* _GLTHREAD_H*/
diff --git a/src/mesa/main/marshal.h b/src/mesa/main/marshal.h
new file mode 100644
index 00000000000..ad32b6b3f4d
--- /dev/null
+++ b/src/mesa/main/marshal.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/** \file marshal.h
+ *
+ * Declarations of functions related to marshalling GL calls from a client
+ * thread to a server thread.
+ */
+
+#ifndef MARSHAL_H
+#define MARSHAL_H
+
+#include "main/glthread.h"
+#include "main/context.h"
+
+struct marshal_cmd_base
+{
+   /**
+    * Type of command.  See enum marshal_dispatch_cmd_id.
+    */
+   uint16_t cmd_id;
+
+   /**
+    * Size of command, in multiples of 4 bytes, including cmd_base.
+    */
+   uint16_t cmd_size;
+};
+
+
+static inline void *
+_mesa_glthread_allocate_command(struct gl_context *ctx,
+                                uint16_t cmd_id,
+                                size_t size)
+{
+   struct glthread_state *glthread = ctx->GLThread;
+   struct marshal_cmd_base *cmd_base;
+
+   if (unlikely(glthread->batch->used + size > MARSHAL_MAX_CMD_SIZE))
+      _mesa_glthread_flush_batch(ctx);
+
+   cmd_base = (struct marshal_cmd_base *)
+      &glthread->batch->buffer[glthread->batch->used];
+   glthread->batch->used += size;
+   cmd_base->cmd_id = cmd_id;
+   cmd_base->cmd_size = size;
+   return cmd_base;
+}
+
+#define DEBUG_MARSHAL_PRINT_CALLS 0
+
+static inline void
+debug_print_sync(const char *func)
+{
+#if DEBUG_MARSHAL_PRINT_CALLS
+   printf("sync: %s\n", func);
+#endif
+}
+
+static inline void
+debug_print_marshal(const char *func)
+{
+#if DEBUG_MARSHAL_PRINT_CALLS
+   printf("marshal: %s\n", func);
+#endif
+}
+
+static inline void
+debug_print_unmarshal(const char *func)
+{
+#if DEBUG_MARSHAL_PRINT_CALLS
+   printf("unmarshal: %s\n", func);
+#endif
+}
+
+struct _glapi_table *
+_mesa_create_marshal_table(const struct gl_context *ctx);
+
+size_t
+_mesa_unmarshal_dispatch_cmd(struct gl_context *ctx, const void *cmd);
+
+static inline void
+_mesa_post_marshal_hook(struct gl_context *ctx)
+{
+   /* This can be enabled for debugging whether a failure is a synchronization
+    * problem between the main thread and the worker thread, or a failure in
+    * how we actually marshal.
+    */
+   if (false)
+      _mesa_glthread_finish(ctx);
+}
+
+#endif /* MARSHAL_H */
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index e53d5762f98..187f2d1bd68 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -4433,6 +4433,8 @@ struct gl_context
    struct _glapi_table *CurrentDispatch;
    /*@}*/
 
+   struct glthread_state *GLThread;
+
    struct gl_config Visual;
    struct gl_framebuffer *DrawBuffer;	/**< buffer for writing */
    struct gl_framebuffer *ReadBuffer;	/**< buffer for reading */
-- 
2.11.1

